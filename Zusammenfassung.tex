\documentclass[12pt,a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage[german]{babel}
\usepackage[T1]{fontenc}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage{float}              
\usepackage{caption}
\usepackage{adjustbox}
\usepackage{lmodern}
\usepackage{fourier}
\usepackage[hidelinks]{hyperref}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{tocloft}
\usepackage[left=2cm,right=2cm,top=2cm,bottom=2cm]{geometry}

\setlength{\cftsubsecnumwidth}{3em}
\setlength{\cftsubsubsecnumwidth}{3.5em}

\lstset{
  basicstyle=\ttfamily\small,
  keywordstyle=\color{blue}\bfseries,
  commentstyle=\color{gray},
  stringstyle=\color{teal},
  frame=single,
  breaklines=true,
  showstringspaces=false,
  extendedchars=true,
  literate=
    {ä}{{\"a}}1
    {ö}{{\"o}}1
    {ü}{{\"u}}1
    {Ä}{{\"A}}1
    {Ö}{{\"O}}1
    {Ü}{{\"U}}1
    {ß}{{\ss}}1
    {ã}{{\~a}}1
    {é}{{\'e}}1
}

\captionsetup[figure]{name=Abb.}

\begin{document}

\tableofcontents
\newpage

\section{Grundlagen Datenbankensysteme}

\subsection{Probleme alternativer Programme}

\begin{itemize}
\item Redundanzen \& Inkonsistenzen
\item eingeschränkter Zugriff auf Daten
\item Probleme bei Mehrbenutzerzugriff
\item Datenverluste, Integritäts- \& Sicherheitsprobleme
\item hoher Entwicklungsaufwand
\end{itemize}

\subsection{Was ein Datenbanksystem ist}

\begin{figure}[H]
\begin{minipage}[t]{0.45\textwidth}
\begin{itemize}
\item \textbf{DBS} = Datenbank (DB) \& Datenbankmanagementsystem (DBMS)
\begin{itemize}
\item \textbf{Datenbank:} Sammlung verknüpfter, persistenter Daten (z. B. Uni mit Studierenden, Kursen usw.)
\item \textbf{DBMS:} Software zur Speicherung, Verwaltung \& Zugriff auf diese Daten
\end{itemize}
\item \textbf{Zweck:} Einheitliche Verwaltung, Zugriff, Integrität, Sicherheit, Transaktionen, Wiederherstellung
\end{itemize}
\end{minipage}
\hfill
\begin{minipage}[t]{0.45\textwidth}
\centering
\vspace{5mm}
\adjustbox{valign=c}{\includegraphics[scale=0.35]{pictures/FunkDBS.png}}
\caption{Funktion Datenbanksystem}
\end{minipage}
\end{figure}

\subsection{Codds 12 Regeln (Zweck eines DBS)}

\begin{itemize}
\item einheitliche Datenintegration
\item effizienter Zugriff über Datenbanksprachen
\item Metadatenkatalog
\item versch. Benutzer-/Anwendungssichten
\item Integritätsbedingungen von DBMS sichergestellt
\item Sicherheitsmechanismen für Schutz der Daten
\item Transaktionen, Synchronisation \& Widerherstellung nach BSOD
\item Unterstützung für Ad-hoc Anfragen \& Schnittstellen
\end{itemize}

\subsection{Datenabstraktion \& Sichten}

\begin{itemize}
\item Drei Ebenen:
\begin{enumerate}
\item \textbf{physical level:} Spreicherung \& Strukturen
\item \textbf{logical level:} Datenmodell, Entities \& Beziehungen
\item \textbf{view level:} Benutzer- \& Anwendungssicht
\end{enumerate}
\item \textbf{Ziel:} Abstraktion \& Datenunabhängigkeit
\begin{itemize}
\item \textbf{Physische Datenunabhängigkeit:} Speicher ändern ohne Logikänderung
\item \textbf{Logische Datenunabhängigkeit:} Logik ändern ohne Anwendungscode anzupassen
\end{itemize}
\end{itemize}

\begin{figure}[H]
\centering
\includegraphics[scale=0.5]{pictures/Datensicht.png}
\caption{Sicht auf Daten}
\end{figure}

\subsection{Schemata \& Instanzen}

\begin{itemize}
\item Instanz = Inhalt
\item Schema = Struktur
\begin{itemize}
\item konzeptionell/logisch: Grundlage für Design
\item Sicht (externes Schema): während Anforderungsanalyse definiert
\item physisch: Speicherstrukturen mit Relationen verbunden
\end{itemize}
\end{itemize}

\subsection{Datenmodelle}

\begin{itemize}
\item \textbf{konzeptionell}: Entity Relationship (ER)-Modell, semantisch, objektorientiert
\item \textbf{logisch}: relational, objektrelational, hierarchisch, Netzwerk, XML/JSON
\end{itemize}

\subsection{Datenbanksprachen}

\begin{itemize}
\item \textbf{DDL (Data Definition Language):} \\
definiert Schemata \& Metadaten (z.B. CREATE TABLE)
\item \textbf{DML (Data Manipulation Language):} \\
Zugriff \& Veränderung der Daten (z.B. SELECT, INSERT)
\begin{itemize}
\item prozedural: wie abgefragt
\item deklarativ: was abgefragt (SQL), nicht prozedural
\end{itemize}
\end{itemize}

\subsection{Anwendungsarchitekturen}

\begin{itemize}
\item basiert auf Client-Server-Modell
\item Trennung der Funktionalitäten einer Anwendung:
\begin{itemize}
\item Benutzeroberfläche \& Interaktion
\item Anwendungslogik (Business Logic)
\item Datenverwaltungsfunktionalität (Speicherung, Verwaltung, Zugriff)
\end{itemize}
\end{itemize}

\begin{figure}[H]
\centering
\begin{minipage}[t]{0.32\textwidth}
\centering
\includegraphics[width=\textwidth]{pictures/cs.png}
\caption{Client-Server-Modell}
\end{minipage}
\hfill
\begin{minipage}[t]{0.32\textwidth}
\centering
\includegraphics[width=\textwidth]{pictures/2s.png}
\caption{2-schichtige Architektur}
\end{minipage}
\hfill
\begin{minipage}[t]{0.32\textwidth}
\centering
\includegraphics[width=\textwidth]{pictures/3s.png}
\caption{3-schichtige Architektur}
\end{minipage}
\end{figure}

\section{Relationales Modell}

\subsection{Grundlagen}

\begin{itemize}
\item Erfinder: Edgar F. Codd (IBM, 1970), Turing Award 1981
\item Bedeutung: Grundlage fast aller modernen Datenbanksysteme \\
(z. B. Oracle, MySQL, PostgreSQL)
\item Kernidee: Daten in Relationen (Tabellen) gespeichert, mit starker mathematischer Basis
\end{itemize}

\subsection{Zentrale Begriffe}

\begin{itemize}
\item \textbf{Domäne:} Wertebereich eines Attributs (Zahl, Farbe, String, Datum, usw.)
\item \textbf{Kartesisches Produkt:} Kombination aller möglichen Werte aus Menge
\item \textbf{Relation:} Menge von n-Tupeln, Teilmenge vom kartesischem Produkt
\item \textbf{Attribut:} Spalte einer Relation
\item \textbf{Grad (Stelligkeit):} Anzahl der Attribute
\item \textbf{Kardinalität:} Anzahl an Tupeln der Relation
\item \textbf{Wichtiges:} Reihenfolge egal, aber keine Duplikate erlaubt
\end{itemize}

\subsection{Relationen- \& Datenbankschema}

\begin{itemize}
\item \textbf{Relationsschema:} legt Struktur der Relation fest \\
$\rightarrow$ z.B. Student(StudId: number, StudName: string, Major: string)
\item \textbf{Instanz eines Datenbankschemas/Relationeninstanz r(R):} Sammlung von Relationen
\item \textbf{Geordnetes Schema:} Position der Attribute relevant
\item \textbf{Ungeordnetes Schema:} Attribute über Namen referenziert
\end{itemize}

\begin{figure}[H]
\centering
\includegraphics[scale=0.55]{pictures/bspRelationsinstanz.png}
\caption{Beispiel einer Relationsinstanz}
\end{figure}

\subsection{Integritätsbedingungen}

Stellt Korrektheit, Konsistenz \& Gültigkeit der Daten sicher:
\begin{itemize}
\item \textbf{Primärschlüssel:} Eindeutiger Identifier für jedes Tupel
\item \textbf{Fremdschlüssel:} Verweist auf Primärschlüssel einer anderen Relation
\item \textbf{Eindeutigkeit (UNIQUE)} \& \textbf{NOT NULL}
\item \textbf{Referenzielle Integrität:} Keine defekten Verweise (Fremdschlüssel muss existieren oder NULL sein)
\end{itemize}

\textbf{$\Rightarrow$ Muss unbedingt für jede Instanz eines Relationsschemas erfüllt sein:}
\begin{itemize}
\item bei Definition des Schemas angegeben
\item vom DBMS bei Änderungen an Relationen überprüft
\end{itemize}

\subsection{Schlüsseltypen}

\begin{itemize}
\item \textbf{Schlüssel $R(S \subseteq R)$:} eindeutig \& minimal
\item \textbf{Superschlüssel $S \subseteq R$:} eindeutig, aber nicht minimal
\item \textbf{zsmgesetzter Schlüssel:} Kombination mehrerer Attribute
\item \textbf{Kanditatenschlüssel:} mögliche Schlüssel
\item \textbf{Primärschlüssel:} ausgewählter Kandidatenschlüssel
\item \textbf{Fremdschlüssel:} verweist auf Primärschlüssel referenzierter Relation
\end{itemize}

\begin{figure}[H]
\begin{minipage}[t]{0.45\textwidth}
\centering
\includegraphics[scale=0.4]{pictures/sd1.png}
\caption{Tupel in A ohne Partner in B unzulässig}
\end{minipage}
\hfill
\begin{minipage}[t]{0.5\textwidth}
\centering
\includegraphics[scale=0.4]{pictures/sd2.png}
\caption{Löschen von Tupel in B nicht möglich, wenn referenziert}
\end{minipage}
\end{figure}

\subsection{SQL Data Definition Language (DDL)}

\textbf{Definiert Relationen \& Integritätsbedingungen:}
\begin{lstlisting}[language = SQL]
CREATE TABLE Student (
  StudId INTEGER PRIMARY KEY,
  StudName VARCHAR(50) NOT NULL,
  Major VARCHAR(50)
);
\end{lstlisting}

\subsubsection{Grundlegende Datentypen}

\begin{itemize}
\item \textcolor{blue}{INTEGER} (auch: \textcolor{blue}{INTEGER4}, \textcolor{blue}{INT})
\item \textcolor{blue}{SMALLINT} (auch: \textcolor{blue}{INTEGER2})
\item \textcolor{blue}{FLOAT} und \textcolor{blue}{DOUBLE}
\item \textcolor{blue}{DECIMAL(p,q)} und \textcolor{blue}{NUMERIC(p,q)} mit $p$ = Gesamtanzahl der Stellen und $q$ = Anzahl der Nachkommastellen
\item \textcolor{blue}{CHARACTER(n)}, \textcolor{blue}{CHAR(n)} – Zeichenketten fester Länge $n$
\item \textcolor{blue}{VARCHAR(n)} – Zeichenketten variabler Länge (bis maximal $n$)
\item \textcolor{blue}{DATE}, \textcolor{blue}{TIME}, \textcolor{blue}{TIMESTAMP} – für Datums- und Zeitangaben
\end{itemize}

\subsubsection{Wichtige SQL-Constraints}

\begin{itemize}
\item  \textcolor{blue}{PRIMARY KEY}: zsmgesetzter Primärschlüssel ($A_1, A_2, ...$) 
\item \textcolor{blue}{UNIQUE}: zsmgesetzter Kandidatenschlüssel ($A_1, A_2, ...$) 
\item \textcolor{blue}{NOT NULL}: Attributwert undefiniert unzulässig
\item \textcolor{blue}{DEFAULT} $w_1$: $w_1$ als Standard genutzt 
\item \textcolor{blue}{CHECK} f: überprüft bei jedem Einfügen Formel f
\item \textcolor{blue}{REFERENCES} $t_1(a_1)$: Verweis Attribut $a_1$ auf Tabelle $t_1$
\item Beispiel für Fremdschlüssel:
\begin{lstlisting}[language = SQL]
FOREIGN KEY (courseId, semester) REFERENCES Course
\end{lstlisting}
\item \textcolor{blue}{ON DELETE CASCADE}: \\
Löschen eines Tupels in B führt zum Löschen aller referenzierenden Tupel in A
\item \textcolor{blue}{ON UPDATE CASCADE}: \\
Änderung eines Tupels in B führt zur automatischen Änderung der referenzierenden Tupel in A
\item \textcolor{blue}{ON DELETE SET NULL}: \\
\glqq Herrenlose Referenzen\grqq ~in A werden auf \textcolor{blue}{NULL} gesetzt
\end{itemize}

\subsubsection{Änderung an Tabellen}

\begin{itemize}
\item \textcolor{blue}{DROP TABLE} t1: löscht Tabelle
\item \textcolor{blue}{ALTER TABLE} ... \textcolor{blue}{ADD}: fügt Attribut hinzu
\item \textcolor{blue}{ALTER TABLE} ... \textcolor{blue}{DROP}: entfernt Attribut
\item \textcolor{blue}{ALTER TABLE} ... \textcolor{blue}{MODIFY}: ändert Attributdefinition
\end{itemize}

\section{Relationale Algebra}

\subsection{Anfragesprachen}

\begin{itemize}
\item Anfragesprache (QL) ermöglicht Daten aus Datenbank auszulesen \& manipulieren
\item relationale Algebra $\rightarrow$ prozedural (SQL)
\item relationales Kalkül $\rightarrow$ deklarativ (QBE, Query-By-Example)
\end{itemize}

\subsection{Basisoperationen der relationalen Algebra}

\textbf{Unäre Operatoren}
\begin{itemize}
\item Selektion $\sigma_P(r)$: filtert Tupel nach Bedingung \\
r $\rightarrow$ Relation (Name) \\
P $\rightarrow$ Formel der Aussagenlogik: <Attribut> = <Attribut> oder <Konstante>
\item Projektion $\pi_{A_1,...,A_k}(r)$: wählt Spalte aus, entfernt Duplikate \\
$A_1,...,A_k$ $\rightarrow$ Attribute \\
Kardinalität: $\mid \pi_{A_1,...,A_k}(r) \mid \ll \mid r \mid$
\item Umbenennung $\phi$: benennt Relationen oder Attribute um \\
$\phi_x(E)$ $\rightarrow$ Ausdruck E unter neuem Namen x
\end{itemize}

\noindent
\textbf{Binäre Operatoren}
\begin{itemize}
\item Vereinigung $\cup$: Tupel aus beiden Relationen
\item Differenz $-$: wie das logische \glqq Ohne\grqq zu verstehen
\item Kartesisches Produkt $\times$: Kombi von Tupeln aus r \& s
\end{itemize}

\begin{figure}[H]
\begin{minipage}[t]{.33\textwidth}
\centering
\includegraphics[scale=.25]{pictures/verein.png}
\caption{Vereinigung}
\end{minipage}
\hfill
\begin{minipage}[t]{.33\textwidth}
\centering
\includegraphics[scale=.25]{pictures/diff.png}
\caption{Differenz}
\end{minipage}
\hfill
\begin{minipage}[t]{.33\textwidth}
\centering
\includegraphics[scale=.25]{pictures/kat.png}
\caption{Kartesiches Produkt}
\end{minipage}
\end{figure}

\subsection{Zusätzliche Operatoren}


\begin{itemize}
\item Schnittmenge $\cap$: gemeinsame Tupel beider Relationen
\begin{figure}[H]
\centering
\includegraphics[scale=.3]{pictures/schnitt.png}
\end{figure}
\item Division $\div$: für \glqq für alle\grqq -Anfragen
\begin{figure}[H]
\centering
\includegraphics[scale=.3]{pictures/div.png}
\end{figure}
\item natürlicher Verbund (Join) $\bowtie$: verbindet Relationen über gleiche Attribute
\begin{figure}[H]
\begin{minipage}[t]{.5\textwidth}
\centering
\includegraphics[scale=.3]{pictures/join1.png}
\caption{Equi-Verbund (Join) mit selben Attribut}
\end{minipage}
\hfill
\begin{minipage}[t]{.5\textwidth}
\centering
\includegraphics[scale=.35]{pictures/join2.png}
\caption{Join ohne selbem Attribut}
\end{minipage}
\end{figure}
\item Theta-Verbund $\bowtie_C$: verbindet Relationen nach beliebiger Bedingung
\begin{figure}[H]
\centering
\includegraphics[scale=.35]{pictures/theta.png}
\end{figure}
\newpage
\item Outer-Joins: behalten auch Tupel ohne Partner
\begin{figure}[H]
\begin{minipage}[t]{.45\textwidth}
\centering
\includegraphics[scale=.3]{pictures/fullouter.png}
\caption{Full-Outer Join}
\end{minipage}
\hfill
\begin{minipage}[t]{.45\textwidth}
\centering
\includegraphics[scale=.3]{pictures/leftrightouter.png}
\caption{Left- \& Right-Outer Join}
\end{minipage}
\end{figure}
\end{itemize}

\subsection{Gruppierung \& Aggregation}

\begin{itemize}
\item Gruppierung: Gruppieren von Tupeln nach gemeinsamen Attributwerten
\item Aggregation: Anwenden einer Funktion auf jede Gruppe (z. B. count, avg, sum, min, max)
\item Notation :$\gamma_{A_1,...A_n;F_1,...F_n}(r)$ \\
$A_i \rightarrow$ Attribut \\
$F_I \rightarrow$ Aggregatfunktion
\end{itemize}

\begin{figure}[H]
\centering
\includegraphics[scale=.5]{pictures/gruppaggr.png}
\caption{Beispielanfrage}
\end{figure}

\subsection{Graphische Darstellung relationaler Algebra-Ausdrücke}

\begin{figure}[H]
\begin{minipage}[t]{.45\textwidth}
\begin{itemize}
\item Darstellung als Baum
\item Knoten = Operatoren (Ausdrücke)
\item Kanten = Datenfluss (Relationen)
\end{itemize}
\end{minipage}
\hfill
\begin{minipage}[t]{.45\textwidth}
\centering
\vspace{-10mm}
\adjustbox{valign=c}{\includegraphics[scale=.3]{pictures/grafalg.png}}
\caption{Beispieldarstellung}
\end{minipage}
\end{figure}

\newpage

\section{Relationenkalkül}

\textbf{Ziel:} Datenbankabfragen mittels des Kalküls formulieren \\
\textbf{Unterschied zur Relationenalgebra:} hier deklarativ, Fokus auf das \glqq Was\grqq

\subsection{Tupelkalkül (TRC)}

\begin{itemize}
\item Edgar F. Codd, als Teil des relationalen Modells
\item Basis vieler Abfragesprachen (QUEL, SQL)
\item Ausdrucksform: $\{t \mid \Psi(t)\}$
\item t: Tupelvariable
\item $\Psi(t)$: logische Bedingung, die erfüllt sein muss
\end{itemize}

\noindent
\textbf{Bestandteile}

\begin{itemize}
\item Atome:
\begin{itemize}
\item $R(t)$: t is Tupel aus Relation R
\item $t.A \Theta s.B$ oder $t.A \Theta c$
\end{itemize}
\item Formeln:
\begin{itemize}
\item Logische Operatoren ($\neg, \vee, \wedge$)
\item Quantoren ($\exists, \forall$)
\item Implikation ($\rightarrow$)
\item Jedes Atom ist auch eine Formel!
\end{itemize}
\end{itemize}

\begin{figure}[H]
\centering
\includegraphics[scale=.4]{pictures/bspformeltrc.png}
\caption{Beispielanfragen TRC}
\end{figure}

\subsection{Semantik}

\begin{itemize}
\item Tupelvariablen: konkrete Tupel
\item Formeln: Wahrheitswerte
\item Ausdrücke: Relationen
\item Quantoren
\begin{itemize}
\item $\exists$: OR-Verknüpfung
\item $\forall$: AND-Verknüpfung
\end{itemize}
\end{itemize}

\subsection{Sichere Ausdrücke}

\begin{itemize}
\item Ohne Einschränkung können unendliche Ergebnisse entstehen
\item Sichere Ausdrücke liefern nur endliche, berechenbare Ergebnisse $\rightarrow$ realistisch für Datenbanken
\end{itemize}

\subsection{Domänenkalkül (DRC)}

\begin{itemize}
\item Variablen für einzelne Attribute
\item Ausdruck: $\{x_1,x_2 \mid \Psi (x_1,x_2,...)\}$
\item Formeln analog zu TRC
\end{itemize}

\begin{figure}[H]
\centering
\includegraphics[scale=.4]{pictures/bspformeldrc.png}
\caption{Beispielformeln DRC}
\end{figure}

\subsection{Query By Example (QBE)}

\begin{itemize}
\item praktische, visuelle Sprache basierend auf DRC
\item Eingabe über Tabellenskelette mit Variablen (\_x, \_y) \& Befehlen:
\begin{itemize}
\item P. $\rightarrow$ print/select
\item I. $\rightarrow$ insert
\item D. $\rightarrow$ delete
\item U. $\rightarrow$ update
\end{itemize}
\item Join über gleiche Variablen
\item kein NOT verfügbar
\end{itemize}

\begin{figure}[H]
% Obere Reihe
\begin{minipage}[t]{.45\textwidth}
\centering
\includegraphics[scale=.3]{pictures/qbedia1.png}
\end{minipage}
\hfill
\begin{minipage}[t]{.45\textwidth}
\centering
\includegraphics[scale=.3]{pictures/qbedia2.png}
\end{minipage}
\\[1em] % Abstand zwischen den Reihen
% Untere Reihe
\begin{minipage}[t]{.45\textwidth}
\centering
\includegraphics[scale=.3]{pictures/qbedia3.png}
\end{minipage}
\hfill
\begin{minipage}[t]{.45\textwidth}
\centering
\includegraphics[scale=.3]{pictures/qbedia4.png}
\end{minipage}
\caption{Beispieldialog in QBE}
\end{figure}

\begin{figure}[H]
\begin{minipage}[t]{.45\textwidth}
\centering
\includegraphics[scale=.3]{pictures/qbe1.png}
\caption{Abfragen mit Bedingungen}
\end{minipage}
\hfill
\begin{minipage}[t]{.45\textwidth}
\centering
\includegraphics[scale=.3]{pictures/qbe2.png}
\caption{Join-Abfragen in QBE}
\end{minipage}
\\[1em]
\begin{minipage}[t]{.45\textwidth}
\centering
\includegraphics[scale=.3]{pictures/qbe3.png}
\caption{QBE-Abfragen mit Ungleichungen}
\end{minipage}
\hfill
\begin{minipage}[t]{.45\textwidth}
\centering
\includegraphics[scale=.3]{pictures/qbe4.png}
\caption{Abfrage mit Negation}
\end{minipage}
\\[1em]
\begin{minipage}[t]{.45\textwidth}
\centering
\includegraphics[scale=.3]{pictures/qbe5.png}
\caption{Einfügungen}
\end{minipage}
\hfill
\begin{minipage}[t]{.45\textwidth}
\centering
\includegraphics[scale=.3]{pictures/qbe6.png}
\caption{Löschungen \& Aktualisierungen}
\end{minipage}
\\[1em]
\centering
\includegraphics[scale=.3]{pictures/qbe7.png}
\caption{Realisierung QBE-Abfrage ohne Negation}
\end{figure}

\newpage

\section{SQL}

\textbf{basiert auf Mengen- \& relationalen Operatoren mit Modifikationen \& Erweiterungen}

\subsection{Grundsruktur einer SQL-Abfrage}

\begin{lstlisting}[language = SQL]
SELECT A1, A2, ... -- Projektion
  FROM R1, R2, ... -- Kreuzprodukt
 WHERE Bedingung -- Selektion
\end{lstlisting}

\subsection{Basisbestandteile}

\textbf{\textcolor{blue}{SELECT}}
\begin{itemize}
\item listet Attribute bzw. Ausdrücke
\item \texttt{*} gibt alle Attribute aus
\item \texttt{\textcolor{blue}{DISTINCT}} entfernt Duplikate
\item Ausdrücke möglich (\texttt{\textcolor{blue}{CAST}...\textcolor{blue}{AS}}, \texttt{\textcolor{blue}{REPLACE}})
\item Alias mit \texttt{\textcolor{blue}{AS}}
\end{itemize}

\noindent
\textbf{\textcolor{blue}{FROM}}
\begin{itemize}
\item enthält Relationen
\item mehrere Relationen $\rightarrow$ kartesisches Produkt
\item gleiche Attributnamen: Quali nötig (z.B. \texttt{R.A} \& \texttt{S:A})
\item Selbst-Joins möglich
\end{itemize}

\noindent
\textbf{\textcolor{blue}{WHERE}}
\begin{itemize}
\item filtert Tupel durch Prädikate
\item Vergleichsoperatoren: =, <, >, <=, >=, <>
\item NULL-checks: \texttt{IS NULL}, \texttt{IS NOT NULL}
\item Logik: AND, OR, NOT
\end{itemize}

\begin{figure}[H]
\begin{minipage}[t]{.45\textwidth}
\centering
\includegraphics[scale=.5]{pictures/db1.png}
\end{minipage}
\hfill
\begin{minipage}[t]{.45\textwidth}
\centering
\includegraphics[scale=.35]{pictures/db2.png}
\end{minipage}
\caption{Datenbank- \& Relationenschema}
\end{figure}

\noindent
\textbf{Beispielabfrage mit SQL}
\begin{lstlisting}[language = SQL]
SELECT Kontaktname, CAST(REPLACE("Telefon",'-','') AS INT) AS "NUMMER"
  FROM LIEFERANTEN;
\end{lstlisting}

$\Rightarrow$ Ausgegeben werden die Kontaktnamen \& Telefonnummern.

\subsection{NULL-Werte}

\begin{itemize}
\item NULL = unbekannt/nicht vorhanden
\item Rechenoperatoren mit NULL $\rightarrow$ NULL
\item Logik folgt TRUE/FALSE/NULL
\item Aggregatfunktionen ignorieren \texttt{\textcolor{blue}{NULL}} außer \texttt{\textcolor{blue}{COUNT}(*)}
\end{itemize}

\subsection{Joins}

\begin{itemize}
\item über Bedingungen formuliert oder explizite JOIN-Operatoren
\item Arten:
\begin{itemize}
\item INNER JOIN
\item LEFT/RIGHT OUTER JOIN
\item FULL OUTER JOIN
\item NATURAL JOIN/JOIN USING
\end{itemize}
\item Special: FULL OUTER JOIN kann simuliert werden mit:
\begin{lstlisting}[language = SQL]
SELECT ... FROM A LEFT JOIN B ...
UNION
SELECT ... FROM A RIGHT JOIN B ...
\end{lstlisting}
\end{itemize}

\noindent
Typische Anwendungen:
\begin{itemize}
\item Kunden + Bestellungen
\item Produkte + Angebote
\item Selbst-Joins (z.B. Kunden in gleicher Stadt)
\end{itemize}

\subsection{Mengenoperationen}

\begin{itemize}
\item \texttt{\textcolor{blue}{UNION}} ($\cap$, ohne Duplikate)
\item \texttt{\textcolor{blue}{UNION ALL}} (mit Duplikaten)
\item \texttt{\textcolor{blue}{INTERSECT}} ($\cup$)
\item \texttt{\textcolor{blue}{EXCEPT}} ($-$, wie das logische Ohne)
\item Anforderungen:
\begin{enumerate}
\item gleiche Anzahl an Spalten
\item kompatible Datentypen
\end{enumerate}
\end{itemize}

\subsection{ORDER BY \& Sortierung}

\begin{itemize}
\item \texttt{\textcolor{blue}{ASC}} Standard \& \texttt{\textcolor{blue}{DESC}}
\item mehrere Sortierschlüssel möglich
\item Umgang mit \texttt{\textcolor{blue}{NULL}}:
\begin{itemize}
\item MySQL: \texttt{\textcolor{blue}{NULLS FIRST}}
\item PostgreSQL/DuckDB: \texttt{\textcolor{blue}{NULLS LAST}}
\end{itemize}
\end{itemize}

\subsection{Aggregation \& GROUP BY}

\textbf{Aggregatfunktionen:} \\
\texttt{\textcolor{blue}{SUM}}, \texttt{\textcolor{blue}{COUNT}}, \texttt{\textcolor{blue}{AVG}}, \texttt{\textcolor{blue}{MIN}}, \texttt{\textcolor{blue}{MAX}}

\begin{figure}[H]
\centering
\includegraphics[scale=.5]{pictures/sqlaus.png}
\caption{SQL-Ausführungsreihenfolge}
\end{figure}

\noindent
\textbf{ACHTUNG:} Attribute in \texttt{\textcolor{blue}{SELECT}} ohne Aggregat müssen in \texttt{\textcolor{blue}{GROUP BY}} stehen \& \texttt{\textcolor{blue}{HAVING}} filtert Gruppen, nicht einzelne Tupel. \\
Mit \texttt{\textcolor{blue}{LIMIT}} kann die Ausgabe auf eine bestimmte Anzahl n reduziert werden (z.B. Top 3 Käufer mit den meisten Bestellungen).

\subsection{Subqueries (Unterabfragen)}

\textbf{Arten:}
\begin{itemize}
\item korreliert (bezieht sich auf äußere Abfrage)
\item unkorreliert
\end{itemize}

\noindent
\textbf{Nutzen}
\begin{itemize}
\item Vergleiche mit Standardwerten (z.B. durchschnittlicher Bestellwert)
\item Mengenvergleiche:
\begin{itemize}
\item \texttt{\textcolor{blue}{IN}}: Ausgabe der Datensätze aus Hauptanfrage im Ergebnis der Unterabfrage
\item \texttt{\textcolor{blue}{NOT IN}}: nicht im Ergebnis der Unterabfrage
\item \texttt{\textcolor{blue}{ANY}}: wenn min. eins zu \texttt{\textcolor{blue}{TRUE}} evaluiert
\item \texttt{\textcolor{blue}{ALL}}: \texttt{\textcolor{blue}{TRUE}} wenn alle Werte Bedingung erfüllen
\item \texttt{\textcolor{blue}{EXISTS}}: \texttt{\textcolor{blue}{TRUE}} wenn Unterabfrage min 1 Datensatz liefert
\item \texttt{\textcolor{blue}{NOT EXISTS}}: \texttt{\textcolor{blue}{TRUE}} wenn keine Datensätze liefert
\end{itemize}
\end{itemize}

\newpage

Beispiele:
\begin{itemize}
\item Kunden ohne Bestellung (NOT EXISTS)
\item Produkte günstiger als jedes Getränl (ALL)
\item Kunden mit hoher Bestellung (> 500) (IN)
\end{itemize}

\subsection{Änderung an der Datenbank}

\begin{lstlisting}[language = SQL]
DELETE FROM Kunden WHERE ...
\end{lstlisting}
\noindent
\textbf{Wichtig:} Unterabfragen werden einmal evaluiert, bevor die Löschaktion ausgeführt wird. \\
\\
\noindent
\textbf{\texttt{\textcolor{blue}{INSERT}}}
\begin{itemize}
\item mit oder ohne explizite Attributliste
\item mehrere Werte möglich
\end{itemize}
\begin{lstlisting}[language = SQL]
INSERT INTO KUNDEN(K_ID, Name, Email, Telefon, Adresse, Stadt, Land)
      VALUES (1000,'Scott','scott@gmail.com','12345','321 The Road','Miami','USA');
\end{lstlisting}
\noindent
\textbf{\texttt{\textcolor{blue}{UPDATE}}}
\begin{itemize}
\item einzelnes Attribut oder mehrere ändern
\item Wert kann auch aus Subquery stammen
\end{itemize}
\begin{lstlisting}[language = SQL]
UPDATE KUNDEN
      SET Adresse = (SELECT Adresse FROM KUNDEN WHERE K_ID = 1)
  WHERE K_ID = 1000;
\end{lstlisting}

\section{Fortgeschrittenes SQL}

\subsection{Zeichenkettenverarbeitung}

\textbf{LIKE}
\begin{itemize}
\item \texttt{\%}: beliebig viele Zeichen
\item \texttt{\_}: genau ein Zeichen
\end{itemize}

\begin{lstlisting}[language=SQL]
-- Unternehmen, deren Name die Zeichenfolge 'Trader' enthält
SELECT * FROM LIEFERANTEN WHERE Firmenname LIKE '%Trader%';

-- Unternehmen, deren Name mit 'T' beginnt
SELECT * FROM LIEFERANTEN WHERE Firmenname LIKE 'T%';

-- Unternehmen, deren Name mit 's' endet
SELECT * FROM LIEFERANTEN WHERE Firmenname LIKE '%s';

-- Unternehmen, die in Sao Paulo bzw. z.B. São Paulo ansässig sind
SELECT * FROM LIEFERANTEN WHERE Stadt LIKE 'S_o Paulo';
\end{lstlisting}

\noindent
\textbf{Regex (z.B. DuckDB)}
\begin{itemize}
\item \texttt{\textcolor{blue}{REGEX\_MATCH}} prüft Muster in Strings
\item \texttt{\textcolor{blue}{REGEXP\_REPLACE}} ersetzt Muster, z.B. alle Nicht-Ziffern
\end{itemize}

\begin{lstlisting}[language=SQL]
-- Kunden auswählen, deren Adresse keine Zahl (z.B. Hausnummer) enthält
SELECT * FROM KUNDEN WHERE NOT REGEX_MATCH(Adresse, '\d+');

-- Kundenadressen so umwandeln, dass sie nur noch Zahlen enthalten
SELECT REGEXP_REPLACE(Adresse, '[^\d]', '*', 'g') FROM KUNDEN;
\end{lstlisting}

\subsection{String-Aggregation}

\texttt{\textcolor{blue}{string\_agg}} verkettet Strings mit Trennzeichen

\begin{lstlisting}[language=SQL]
SELECT string_agg("E-mail", ', ') AS distribution_list FROM sample.KUNDEN;
\end{lstlisting}

\subsection{Pivotierung}

\begin{figure}[H]
\centering
\includegraphics[scale=.5]{pictures/pivot.png}
\caption{Spalten in Zeilen transformieren (andersrum geht auch)}
\end{figure}

\textbf{\textcolor{blue}{FILTER}} in Aggregaten
\begin{lstlisting}[language=SQL]
SELECT Land, SUM(Bevoelkerung) FILTER (WHERE Jahr = 2000) "2000",
             SUM(Bevoelkerung) FILTER (WHERE Jahr = 2010) "2010",
             SUM(Bevoelkerung) FILTER (WHERE Jahr = 2020) "2020"
FROM Städte
GROUP BY Land;
\end{lstlisting}

\noindent
\textbf{\textcolor{blue}{CASE WHEN}} 
\begin{lstlisting}[language=SQL]
SELECT Land, SUM(CASE WHEN Jahr = 2000 THEN Bevoelkerung END) AS "2000",
             SUM(CASE WHEN Jahr = 2010 THEN Bevoelkerung END) AS "2010",
             SUM(CASE WHEN Jahr = 2020 THEN Bevoelkerung END) AS "2020"
FROM Städte
GROUP BY Land;
\end{lstlisting}

\noindent
\textbf{\textcolor{blue}{PIVOT}} (z.B. DuckDB)
\begin{lstlisting}[language=SQL]
SELECT * FROM (
    PIVOT Städte ON Jahr USING SUM(Bevoelkerung) GROUP BY Land
) pivot_alias;
\end{lstlisting}

\subsection{CTEs \& Sichten}

\subsubsection{CTEs (Common Table Expressions)}

\begin{itemize}
\item tempräre benannte Zwischentabellen innerhalb einer Abfrage
\item Syntax
\begin{lstlisting}[language=SQL]
WITH <abfrage-name> [(<spaltenliste>)] AS ( <abfrageausdruck> )
\end{lstlisting}
\item erhöht Lesbarkeit komplexer Queries
\end{itemize}

\noindent
\textbf{CTE Beispiele}
\begin{lstlisting}[language=SQL]
-- ohne WITH-Klausel
SELECT * FROM PRODUKTE WHERE PreisProEinheit <= (
  SELECT AVG(PreisProEinheit) * 1.1 FROM PRODUKTE)
AND PreisProEinheit >= (
  SELECT AVG(PreisProEinheit) * 0.9 FROM PRODUKTE);
 
-- mit WITH-Klausel 
WITH AVERAGE(AvgPrice) AS (SELECT AVG(PreisProEinheit) FROM sample.PRODUKTE)
SELECT P.* FROM sample.PRODUKTE P, AVERAGE
  WHERE P.PreisProEinheit <= 1.1 * AvgPrice AND P.PreisProEinheit >= 0.9 * AvgPrice;
  
-- Finde die Top 5 Kunden nach Gesamtausgaben für Bestellungen
WITH CustomerTotalSpending AS (
    SELECT K.K_ID, K.Name, SUM(B.Gesamtbetrag) AS Gesamtbetrag
      FROM sample.KUNDEN K JOIN sample.BESTELLUNGEN B ON K.K_ID = B.K_ID
     GROUP BY K.K_ID, K.Name
)
SELECT K_ID, Name, Gesamtbetrag
  FROM CustomerTotalSpending
 ORDER BY Gesamtbetrag DESC
 LIMIT 5;
\end{lstlisting}

\subsubsection{Views (Sichten)}

\begin{itemize}
\item dauerhafte virtuelle Tabellen
\item Nutzen: Abstrkation, Wiederverwendung \& Sicherheit
\end{itemize}

\newpage
\noindent
\textbf{Definition der Sicht (DDL-Befehl)}
\begin{lstlisting}[language=SQL]
CREATE VIEW OrderDetailsView AS
SELECT B.B_ID, B.Bestelldatum, B.Gesamtbetrag,
      K.Name AS KundenName, K."E-Mail" AS KundenEmail,
      L.Firmenname AS LieferantenName, L.Kontaktperson AS LieferantenKontakt
FROM BESTELLUNGEN B JOIN KUNDEN K ON B.K_ID = K.K_ID JOIN LIEFERANTEN L ON B.L_ID =
    L.L_ID;
\end{lstlisting}

\noindent
\textbf{Verwendung der Sicht über ihren Namen}
\begin{lstlisting}[language=SQL]
SELECT B_ID, Bestelldatum, KundenName, LieferantenName, Gesamtbetrag
FROM OrderDetailsView
WHERE Gesamtbetrag > 500
ORDER BY Bestelldatum DESC;
\end{lstlisting}

\begin{figure}[H]
\centering
\includegraphics[scale=.5]{pictures/ctesvssichten.png}
\caption{Vergleich: CTEs vs. Sichten}
\end{figure}

\subsection{Rekursive Anfragen}

\textbf{Anwendungen}
\begin{itemize}
\item Graphen, Flugverbindungen, Transitive Hülle
\item Baumstrukturen
\item Fibonacci-Zahlen
\end{itemize}

\noindent
\textbf{Grundstruktur}
\begin{lstlisting}[language=SQL]
WITH RECURSIVE R AS (
  -- Basis
  SELECT ...
  UNION ALL
  -- Rekursiver Schritt
  SELECT ... FROM R ...
)
SELECT * FROM R;
\end{lstlisting}

\noindent
\textbf{Sicherheitsmechanismen}
\begin{itemize}
\item Begrenzung der Rekursionstiefe
\item Zykluserkennung (\textcolor{blue}{CYCLE}-Klausel)
\end{itemize}

\begin{lstlisting}[language=SQL]
WITH RECURSIVE TRIP(ABFLUG, ANKUNFT, VERBINDUNG) AS (
    SELECT ABFLUG, ANKUNFT, ABFLUG || '-' || ANKUNFT AS Con
      FROM FLÜGE
     WHERE ABFLUG = 'FRA'
        UNION ALL
     SELECT T.ABFLUG, F.ANKUNFT, T.VERBINDUNG || '-' || F.ANKUNFT AS Con
       FROM TRIP T, FLÜGE F
      WHERE T.ANKUNFT = F.ABFLUG
) CYCLE ANKUNFT SET FoundCycle TO TRUE DEFAULT FALSE USING cycle_path
SELECT * FROM TRIP;
\end{lstlisting}

\begin{figure}[H]
\centering
\includegraphics[scale=.45]{pictures/cyc.png}
\caption{Sicherheit durch Zykluserkennung}
\end{figure}

\subsection{Baum- \& Graphtraversierungen}

\begin{figure}[H]
\begin{minipage}[t]{.45\textwidth}
\centering
\includegraphics[scale=.3]{pictures/baum.png}
\end{minipage}
\hfill
\begin{minipage}[t]{.45\textwidth}
\centering
\includegraphics[scale=.3]{pictures/graph.png}
\end{minipage}
\caption{Traversierungen durch den Baum \& Graph}
\end{figure}

Mit rekursiven CTEs lassen sich:
\begin{itemize}
\item vollständige Pfade erzeugen
\item Zyklen vermeiden
\item \glqq visited nodes\grqq ~tracken
\end{itemize}

\noindent
\textbf{Gib alle Pfade zurück, die bei Knoten 1 beginnen}
\begin{lstlisting}[language=SQL]
WITH RECURSIVE paths(startNode, endNode, path) AS (
   -- definiere den Pfad als die erste Kante der Traversierung
   SELECT node1id AS startNode, node2id AS endNode, [node1id, node2id] AS path
     FROM edges
     WHERE startNode = 1
   UNION ALL
   -- neue Kante an den Pfad anhängen
   SELECT paths.startNode AS startNode, node2id AS endNode,
         array_append(path, node2id) AS path
     FROM paths JOIN edges ON paths.endNode = node1id
     -- Verhindert das Hinzufügen eines bereits enthaltenen Knotens (stellt Zyklenfreiheit sicher)
     WHERE node2id != ALL(paths.path)
)
SELECT startNode, endNode, path FROM paths ORDER BY length(path), path;
\end{lstlisting}

\noindent
\textbf{Gib ungewichtete kürzeste Pfade zurück, die bei Knoten 1 beginnen}
\begin{lstlisting}[language=SQL]
WITH RECURSIVE paths(startNode, endNode, path) AS (
     -- definiert den Pfad als die erste Kante der Traversierung
   SELECT node1id AS startNode, node2id AS endNode, [node1id, node2id] AS path
     FROM edges WHERE startNode = 1
   UNION ALL
   -- neue Kante an den Pfad anhängen
   SELECT paths.startNode AS startNode, node2id AS endNode,
          array_append(path, node2id) AS path
     FROM paths JOIN edges ON paths.endNode = node1id
    -- Verhindert das Hinzufügen eines Knotens, der bereits von einem Pfad besucht wurde.
    -- Dadurch wird sichergestellt, dass (1) keine Zyklen auftreten und
    -- (2) nur Knoten hinzugefügt werden, die nicht von früheren (kürzeren) Pfaden besucht wurden.
    WHERE NOT EXISTS (SELECT 1
                      FROM paths previous_paths
                      WHERE list_contains(previous_paths.path, node2id))
)
SELECT startNode, endNode, path FROM paths ORDER BY length(path), path;
\end{lstlisting}

\subsection{Window Funktionen}

\begin{figure}[H]
\centering
\includegraphics[scale=.6]{pictures/wf.png}
\caption{Grundprinzip von Window-Funktionen}
\end{figure}

\newpage
\noindent
\textbf{Wichtige Konzepte}
\begin{itemize}
\item current row
\item Fenster-Frame
\item ROWS (positionsbasiert)
\item RANGE (wertbasiert, basiert auf Gleichheit oder Distanz im Sortierattribut)
\end{itemize}

\begin{figure}[H]
\begin{minipage}[t]{.45\textwidth}
\centering
\includegraphics[scale=.25]{pictures/rows1.png}
\end{minipage}
\hfill
\begin{minipage}[t]{.45\textwidth}
\centering
\includegraphics[scale=.25]{pictures/rows2.png}
\end{minipage}
\\[1em]
\begin{minipage}[t]{.45\textwidth}
\centering
\includegraphics[scale=.25]{pictures/rows3.png}
\end{minipage}
\hfill
\begin{minipage}[t]{.45\textwidth}
\centering
\includegraphics[scale=.25]{pictures/rows4.png}
\end{minipage}
\centering
\includegraphics[scale=.3]{pictures/rows5.png}
\caption{ROWS-Beispiele}
\end{figure}

\begin{figure}[H]
\begin{minipage}[t]{.45\textwidth}
\centering
\includegraphics[scale=.25]{pictures/range1.png}
\end{minipage}
\hfill
\begin{minipage}[t]{.45\textwidth}
\centering
\includegraphics[scale=.3]{pictures/range2.png}
\end{minipage}
\\[1em]
\begin{minipage}[t]{.45\textwidth}
\centering
\includegraphics[scale=.3]{pictures/range3.png}
\end{minipage}
\hfill
\begin{minipage}[t]{.45\textwidth}
\centering
\includegraphics[scale=.3]{pictures/range4.png}
\end{minipage}
\caption{RANGE-Beispiel}
\end{figure}

\begin{figure}[H]
\begin{minipage}[t]{.45\textwidth}
\centering
\includegraphics[scale=.3]{pictures/groups1.png}
\end{minipage}
\hfill
\begin{minipage}[t]{.45\textwidth}
\centering
\includegraphics[scale=.3]{pictures/groups2.png}
\end{minipage}
\\[1em]
\begin{minipage}[t]{.45\textwidth}
\centering
\includegraphics[scale=.3]{pictures/groups3.png}
\end{minipage}
\hfill
\begin{minipage}[t]{.45\textwidth}
\centering
\includegraphics[scale=.3]{pictures/groups4.png}
\end{minipage}
\caption{GROUPS-Beispiele}
\end{figure}

\section{Konzeptioneller Datenbankentwurf}

\subsection{Ziel des konzeptionellen Datenbankdesigns}

Das konzeptionelle Design beschreibt einen relevanten Ausschnitt der realen Welt mithilfe eines formalen Modells (ER-Modell). \\
Es ist unabhängig von technischen Implementierungen wie DBMS oder Betriebssystem. \\
Zentrale Fragen:

\begin{itemize}
\item Welche Entitäten und Beziehungen existieren?
\item Welche Attribute sollen erfasst werden?
\item Welche Restriktionen (Regeln) gelten?
\end{itemize}

\subsection{Zwischenschritte im Designprozess}

\begin{enumerate}
\item Natürliche Sprache: funktionales Pflichtenheft
\item Grafische Darstellung: ER-Diagramm
\item Relationales Modell: z.B. Tabellen-Definitionen
\end{enumerate}

\begin{figure}[H]
\centering
\includegraphics[scale=.3]{pictures/dbsdesign.png}
\caption{Datenbankdesign}
\end{figure}

\subsection{Entity-Relationship-Modell}

\begin{itemize}
\item \textbf{Entität:} Objekt der realen Welt (z.B. Auto, Student)
\item \textbf{Entitätstyp:} Menge gleichartiger Entitäten (z.B. alle Studenten)
\item Attribute können sein:
\begin{enumerate}
\item einfach/zusammengesetzt
\item einzelwertig/mehrwertig
\item gespeichert/abgeleitet
\end{enumerate}
\item \textbf{Superschlüssel:} identifiziert Entitäten eindeutig
\item \textbf{Kandidatenschlüssel:} minimaler Superschlüssel
\item \textbf{Primärschlüssel} wird unterstrichen, in diesem Fall gewählter Kandidatenschlüssel
\end{itemize}

\begin{figure}[H]
\centering
\includegraphics[scale=.5]{pictures/erd.png}
\caption{Beispiel eines ER-Diagramms}
\end{figure}

\subsection{Beziehungen \& Beziehungstypen}

\textbf{Beziehungen}
\begin{itemize}
\item Verknüpfung zw. Entities, z.B. Student besucht Kurs
\item haben keine eigenen Schlüssel
\item können Attribute besitzen, die die Beziehung selbst beschreiben (z.B. Besetelldatum)
\end{itemize}

\noindent
\textbf{Rollen}
Entitytyp kann in einer Beziehung mehrfach vorkommen

\begin{figure}[H]
\centering
\includegraphics[scale=.5]{pictures/role.png}
\caption{rekursive Beziehung}
\end{figure}

\subsection{Restriktionen: Kardinalitäten \& Teilnahme}

\begin{figure}[H]
\begin{minipage}[t]{.45\textwidth}
\textbf{Kardinalitätsverhältnisse}
\begin{itemize}
\item N:M (many to many $\rightarrow$ Standard)
\item 1:1 (one to one)
\item 1:N (one to many)
\item N:1 (many to one)
\item 1 im Sinne von 0 oder 1
\item M/N im Sinne von 0 bis $\inf$
\end{itemize}
\end{minipage}
\hfill
\begin{minipage}[t]{.5\textwidth}
\textbf{Teilnahmebedingungen}
\begin{itemize}
\item \textbf{Partielle Teilnahme:} Entity muss nicht teilnehmen
\item \textbf{Totale Teilnahme:} Entity muss Teil min einer Beziehung sein (Exitenzabhängigkeit)\\
z.B. Mitarbeiter muss einer Abteilung zugeordnet sein
\end{itemize}
\end{minipage}
\end{figure}

\begin{figure}[H]
\begin{minipage}[t]{.45\textwidth}
\centering
\includegraphics[width=\linewidth]{pictures/bzrbsp1.png}
\end{minipage}
\hfill
\begin{minipage}[t]{.45\textwidth}
\centering
\includegraphics[width=\linewidth]{pictures/bzrbsp2.png}
\end{minipage}
\\[1em]
\begin{minipage}[t]{.45\textwidth}
\centering
\includegraphics[width=\linewidth]{pictures/bzrbsp3.png}
\end{minipage}
\hfill
\begin{minipage}[t]{.45\textwidth}
\centering
\includegraphics[width=\linewidth]{pictures/bzrbsp4.png}
\end{minipage}
\caption{Beispiele zu den Kardinalitätsverhältnissen}
\end{figure}

\noindent
\textbf{Min-Max-Notation}
\begin{itemize}
\item exakte Vorgabe von min/max Teilnahme einer Entity an einer Beziehung
\item Entity kommt nicht zwingend vor: $min_i = 0$
\item Entity kommt beliebig of vor: $max_i = *$
\item Tupelschreibweise für die Entity: $(min_i, max_i)$
\end{itemize}

\subsection{N-äre Beziehungen}

\begin{itemize}
\item Beziehungen mit mehr als 2 Entities
\item Integritätsbedingungen komplexer
\end{itemize}

\begin{figure}[H]
\centering
\includegraphics[scale=.4]{pictures/när.png}
\caption{Veranschaulichung einer N-ären Beziehung}
\end{figure}

\subsection{Schwache Entities}

\begin{figure}[H]
\begin{minipage}[t]{.45\textwidth}
\begin{itemize}
\item können nicht unabhängig existieren
\item benötigen eine starke Entity für eindeutige Identifizierung
\item typisch über 1:N-Beziehung (1:1 auch möglich)
\item Darstellung: doppelte Umrandung am Rechteck \& doppelte Linie zur Beziehung
\end{itemize}
\end{minipage}
\hfill
\begin{minipage}[t]{.5\textwidth}
\centering
\vspace{5mm}
\includegraphics[width=\linewidth]{pictures/we.png}
\caption{Schwache Entity Beispiel}
\end{minipage}
\end{figure}

\subsection{Generalisierung/Spezialisierung}

\begin{figure}[H]
\begin{minipage}[t]{.45\textwidth}
\begin{itemize}
\item Ziel: Strukturierung von Entitytypen
\item Supertyp umfasst gemeinsame Attribute, Subtypen erben diese
\item Eigenschaften: disjunkt, vollständig
\end{itemize}
\end{minipage}
\hfill
\begin{minipage}[t]{.5\textwidth}
\centering
\vspace{-23mm}
\includegraphics[width=\linewidth]{pictures/gen.png}
\caption{Generalisierung mit Diagramm}
\end{minipage}
\end{figure}

\subsection{Aggregation}

\begin{figure}[H]
\begin{minipage}[t]{.45\textwidth}
\vspace{5mm}
\begin{itemize}
\item Strukturierung versch. Entitytypen bilden zsm neue Einheit
\item Synatx: Beziehungsnotation mit Label part-of
\end{itemize}
\end{minipage}
\hfill
\begin{minipage}[t]{.5\textwidth}
\centering
\vspace{-5mm}
\includegraphics[width=\linewidth]{pictures/bom.png}
\caption{bill of materials}
\end{minipage}
\end{figure}

\subsection{Entwurfsentscheidungen}

\textbf{Typische Entscheidungen}
\begin{itemize}
\item Entity vs. Attribut
\item Entity vs. Beziehung
\item Binäres vs. N-äre Beziehung
\end{itemize}

\begin{figure}[H]
\begin{minipage}[t]{.5\textwidth}
\centering
\includegraphics[width=\linewidth]{pictures/ewe1.png}
\end{minipage}
\hfill
\begin{minipage}[t]{.5\textwidth}
\centering
\includegraphics[width=\linewidth]{pictures/ewe2.png}
\end{minipage}
\caption{Attribut vs. Entity}
\end{figure}

\noindent
\textbf{Schritte beim Entwurf eines ER-Modells}

\begin{enumerate}
\item Identifiziere Entitätstypen (Entitätstyp vs. Attribut)
\item Identifiziere Beziehungstypen
\item Identifiziere und ordne Attribute Entitäten und Beziehungen zu
\item Bestimme Attributdomänen
\item Bestimme Primärschlüsselattribute für Entitätstypen
\item Ordne (verfeinerte) Kardinalitätsverhältnisse den Beziehungstypen zu
\end{enumerate}

\subsection{Übersetzung ER-Schema in relationales Schema}

\begin{figure}[H]
\begin{minipage}[t]{.45\textwidth}
\textbf{Entity $\rightarrow$ Relationen}
\begin{itemize}
\item jeder Entitytyp wird zu einer Tabelle
\item Attribute $\rightarrow$ Spalten
\item Primärschlüssel übernommen
\end{itemize}
\end{minipage}
\hfill
\begin{minipage}[t]{.5\textwidth}
\textbf{Beziehungen}
\begin{itemize}
\item M:N $\rightarrow$ eigene Relation mit Fremdschlüssel auf beide Entities
\item 1:N $\rightarrow$ Fremdschlüssel auf 1-Seite
\item 1:1 $\rightarrow$ Zsmführung möglich
\item N-äre Beziehungen $\rightarrow$ eigene Tabelle mit allen Fremdschlüsseln
\end{itemize}
\end{minipage}
\\
\begin{minipage}[t]{.45\textwidth}
\centering
\includegraphics[width=\linewidth]{pictures/errs1.png}
\end{minipage}
\hfill
\begin{minipage}[t]{.45\textwidth}
\centering
\includegraphics[width=\linewidth]{pictures/errs2.png}
\end{minipage}
\\[1em]
\centering
\includegraphics[scale=.3]{pictures/errs3.png}
\caption{N:M, 1:N \& tenäre Beziehungen}
\end{figure}

\newpage
\noindent
\textbf{Optimierungen}
\begin{itemize}
\item funktionale Beziehungen können Tabellen zsmführen
\item unnötige Relationen vermeiden
\item NULL-Werte vermeiden
\item Relationen für Supertyp \& Subtyp (Join nötig)
\end{itemize}

\begin{figure}[H]
\begin{minipage}[t]{.45\textwidth}
\centering
\includegraphics[width=\linewidth]{pictures/errs4.png}
\caption{Schema ohne NULL-Werte}
\end{minipage}
\hfill
\begin{minipage}[t]{.45\textwidth}
\centering
\includegraphics[width=\linewidth]{pictures/errs5.png}
\caption{mit Join zsmgeführt}
\end{minipage}
\end{figure}

\section{Datenbanknormalisierung}

\subsection{Warum gutes Schema-Desing wichtig ist}

Schlecht entworfene relationale Schemata führen zu:

\begin{itemize}
\item Redundanzen $\rightarrow$ mehrfach gespeicherte Informationen
\item Inkonsistenzen $\rightarrow$ widersprüchliche Daten bei Updates
\item Anomalien bei DML-Operationen:
\begin{itemize}
\item Update-Anomalien \\
nicht alle Duplikate werden geändert
\item Lösch-Anomalien \\
Informationen gehen unbeabsichtigt verloren
\item Einfüge-Anomalien \\
Daten können ohne andere Daten nicht eingefügt werden
\end{itemize}
\item Wartbarkeits- \& Performanceproblemen
\end{itemize}

\noindent
Ziel: Redundanzen vermeiden, ohne Informationen zu verlieren oder Rekonstruktion zu verhindern.

\subsection{Normalisierung}

\begin{itemize}
\item Verfeinerung des logischen Schemas durch Zerlegung von Relationen
\item Anforderungen:
\begin{enumerate}
\item Verlustfreie Zerlegung (Originalrelation rekonstruierbar)
\item Abhängigkeitserhaltende Zerlegung
\end{enumerate}
\item Umsetzung über Normalformen, basierend auf funktionalen Abhängigkeiten
\end{itemize}

\subsection{Funktionale Abhängigkeiten (FDs)}

\begin{itemize}
\item Wert/Menge eines Attributs bestimmt Wert eines Anderen eindeutig
\item funktionale Abhängigkeit X$\rightarrow$Y: gleiche Werte in X $\Rightarrow$ gleiche Werte in Y
\item wenn zwei Tupel mit gleichen Werten in allen Attributen von
X auch gleiche Werte in allen Attributen von Y haben müssen
\end{itemize}

\begin{figure}[H]
\centering
\includegraphics[scale=.4]{pictures/fd.png}
\caption{Beispiele funktionaler Abhängigkeiten}
\end{figure}

\subsection{Arten funktionaler Abhängigkeiten}

\begin{itemize}
\item Triviale funktionale Abhängigkeit: X$\rightarrow$Y mit Y $\subseteq$X
\item Volle funktionale Abhängigkeit: Attribut hängt vom gesamten Schlüssel ab
\item Partielle funktionale Abhängigkeit: Attribut hängt nur von einem Teil des Schlüssels ab
\end{itemize}

\subsection{Schlüsselbegriffe}

\begin{itemize}
\item Superschlüssel: Attributmenge, die Tupel eindeutig identifiziert
\item Kandidatenschlüssel: minimaler Superschlüssel
\item Primärschlüssel: ausgewählter Kandidatenschlüssel
\end{itemize}

\noindent
Zusammenhang:
\begin{itemize}
\item S ist Superschlüssel $\Leftrightarrow$ S$\rightarrow$R
\item S ist Kandidatenschlüssel $\Leftrightarrow$ S$\dot{\rightarrow}$R \& Abhängigkeit ist voll
\end{itemize}

\subsection{Armstrong-Axiome (Ableitungsregeln)}

\begin{enumerate}
\item Reflexivität: Y$\subseteq$X $\Rightarrow$ X$\rightarrow$Y
\item Augmentation/Verstärkung: X$\rightarrow$Y $\Rightarrow$ XZ$\rightarrow$YZ
\item Transitivität: X$\rightarrow$Y $\vee$ Y$\rightarrow$Z $\Rightarrow$ X$\rightarrow$Z
\item Dekomposition: X$\rightarrow$YZ $\Rightarrow$ X$\rightarrow$Y $\vee$ X$\rightarrow$Z
\item Vereinigung: X$\rightarrow$Y $\vee$ X$\rightarrow$Z $\Rightarrow$ X$\rightarrow$YZ
\item Pseudotransitivität: X$\rightarrow$Y $\vee$ YZ$\rightarrow$W $\Rightarrow$ XZ$\rightarrow$W
\end{enumerate}

\subsection{Attributabschluss}

$X^+$ = Menge aller Attribute, die durch X mittels der funktionalen Abhängigkeiten F funktional bestimmt werden können

\begin{enumerate}
\item Initialisierung des Abschlusses
\item Iteration über funktionale Abhängigkeiten
\item Wiederhole bis keine Änderung
\end{enumerate}

\begin{figure}[H]
\centering
\includegraphics[scale=.5]{pictures/attributsabschluss.png}
\caption{Berechnung des Attributsabschlusses (Attribut Hülle)}
\end{figure}

\subsection{Kanonische Überdeckung (Canonical Cover)}

\begin{itemize}
\item Äquivalent zur ursprünglichen FD-Menge
\item Keine überflüssigen Attribute links oder rechts
\item Jede linke Seite ist eindeutig
\item Vereinfachung des Entwurfs
\item Grundlage für Normalisierung (z. B. 3NF, BCNF)
\end{itemize}

\noindent
\textbf{Algoablauf}
\begin{enumerate}
\item Linke Reduktion für jede FD , Resultat ist F'
\item Rechte Reduktion für jede FD (F'), Resultat ist F''
\item Entferne alle FDs der Form X$\rightarrow$ $\varnothing$ aus F''
\item Vereinfache FDs durch die Vereinigungsregel
\end{enumerate}

\newpage
\begin{figure}[H]
\centering
\includegraphics[scale=.5]{pictures/cc.png}
\caption{einfaches Bsp. kanonischer Überdeckung}
\end{figure}

\subsection{Zerlegung relationaler Schemata}

\begin{enumerate}
\item verlustfrei: durch \texttt{JOIN} ursprüngliche Relation ohne Informationsverlust
\item abhängkeitserhaltend: stellt sicher, dass funktionale Abhängigkeiten bestehen bleiben
\end{enumerate}

\subsection{Normalformen}

beschreiben Eigenschaften von Relationsschemata \&
\begin{itemize}
\item verbieten bestimmte funktionale Abhängigkeiten
\item vermeiden Redundanzen
\item verhindern Update-, Insert- \& Delete-Anomalien
\end{itemize}

\noindent
Reihenfolge (immer stärker werdend)
\begin{enumerate}
\item 1NF
\item 2NF
\item 3NF
\item BCNF
\item 4NF (optional / fortgeschritten)
\end{enumerate}

\subsubsection{1. Normalform (1NF)}

\begin{itemize}
\item alle Attribute atomar
\item keine Listen, Arrays oder Mengen als Attributwerte
\item rein strukturell, unabhängig von funktionalen Abhängigkeiten
\end{itemize}

\begin{figure}[H]
\centering
\includegraphics[scale=.45]{pictures/1nf.png}
\caption{1NF Schema}
\end{figure}

\subsubsection{2. Normalform (2NF)}

\begin{itemize}
\item Attribute hängen nur von einem Teil des Schlüssels ab
\item eliminiert partielle Abhängigkeiten
\item 1NF \& kein Nicht-Schlüsselattribut funktional abhängig von einem echten Teil eines Kandidatenschlüssels ist 
\end{itemize}

\begin{figure}[H]
\centering
\includegraphics[scale=.45]{pictures/2nf.png}
\caption{2NF Schema}
\end{figure}

\subsubsection{3. Normalform (3NF)}

\begin{itemize}
\item Vermeidung transitiver Abhängigkeit
\item Nicht-Schlüsselattribute dürfen nicht von anderen Nicht-Schlüsselattributen abhängen
\end{itemize}

\subsubsection{Synthese Algorithmus}

\textbf{Ziel:} automatische Erzeugung einer verlustfreien \& abhängigkeitserhaltenden Zerlegung in 3NF

\begin{enumerate}
\item Bestimme die kanonische Hülle $F_C$ von $F$
\item Erzeuge neue Relationsschemata aus $F_C$
\item Rekonstruiere einen Kandidatenschlüssel
\item Entferne überflüssige Relationen
\end{enumerate}

\begin{figure}[H]
\begin{minipage}[t]{.5\textwidth}
\centering
\includegraphics[width=\linewidth]{pictures/sa1.png}
\end{minipage}
\hfill
\begin{minipage}[t]{.5\textwidth}
\centering
\includegraphics[width=\linewidth]{pictures/sa2.png}
\end{minipage}
\caption{Synthese Algo Bsp.zerlegung}
\end{figure}

\subsubsection{Boyce-Codd-Normalform (BCNF)}

\begin{itemize}
\item vermeidet Redundanzen
\item kann aber Abhängigkeitserhaltung verletzen
\item um BCNF zu sein: Y$\subseteq$X (trivial) oder X ist ein Superschlüssel bei X$\rightarrow$Y
\end{itemize}

\begin{figure}[H]
\centering
\includegraphics[scale=.45]{pictures/bcnf.png}
\caption{BCNF Schema}
\end{figure}

\subsubsection{Mehrwertige Abhängigkeiten (MVD)}

\[X \twoheadrightarrow Y\]

\begin{itemize}
\item Verallgemeinerung einer funktionalen Abhängigkeit
\item Jede funktionale Abhängigkeit ist auch eine mehrwertige Abhängigkeit, aber nicht jede mehrwertige Abhängigkeit ist auch funktional
\item Y mehrwertig abhängig von X (X $\twoheadrightarrow$ Y)
\item zu einem festen Wert von X können mehrere Werte von Y existieren
\item trivial: Y$\subseteq$X oder Y = $\mathcal{R}$ - X
\item triviale MVDs verursachen keine Redundanzen
\item Zerlegung von Relationsschema verlustfrei, wenn Menge funktionale \& mehrwertige Abhängigkeiten hat
\end{itemize}

\subsubsection{4. Normalform (4NF)}

\begin{itemize}
\item Erweiterung von BCNF
\item behandelt mehrwertige Abhängigkeiten (MVDs)
\item Unabhängige Mehrfachfakten sollen nicht kombiniert gespeichert werden
\item 4NF: X$\twoheadrightarrow$Y trivial oder X ist ein Superschlüssel
\end{itemize}

\section{Transaktionsverwaltung}

\subsection{Grundkonzept}

\begin{itemize}
\item eine Folge von Datenbankoperationen, die atomar als eine Einheit ausgeführt wird
\item Typische Einsatzfälle: Online-Buchungssysteme, Banktransaktionen
\item Ohne Transaktionen können Inkonsistenzen entstehen (z. B. doppelte Sitzplatzvergabe)
\end{itemize}

\subsection{Transkationsverarbeitung}

\begin{itemize}
\item serielle Ausführung korrekt, aber ineffizient
\item nebenläufige (parallele) Ausführung erhöht Durchsatz \& reduziert Antwortzeiten
\item Herausforderung: Korrektheit \& Fairness sicherstellen
\end{itemize}

\begin{figure}[H]
\centering
\includegraphics[scale=.5]{pictures/probtrans.png}
\caption{problematische Transaktionen}
\end{figure}

\subsection{Operationen in Transaktionen}

\begin{itemize}
\item Grundoperationen: \texttt{read}, \texttt{write}
\item Steueroperationen
\begin{enumerate}
\item BOT (Begin of Transaction): kennzeichnet Start einer neuen Transaktion
\item Commit: Änderungen werden dauerhaft gespeichert
\item Abort/Rollback: Änderungen rückgängig machen
\end{enumerate}
\end{itemize}

\subsection{ACID-Eigenschaften}

\begin{itemize}
\item Atomicity: Alles-oder-Nichts-Ausführung
\item Consistency: Übergang zw. konsistenten Zuständen ($\rightarrow$ Integritätsbedingungen)
\item Isolation: nebenläufige Transaktionen beinflussen sich nicht sichtbar ($\rightarrow$ Nebenläufigkeitskontrolle)
\item Durability: Änderungen nach Commit bleiben dauerhaft erhalten ($\rightarrow$ Wiederherstellung/Recovery)
\end{itemize}

\subsection{Aufgaben des DBMS bei Transaktionen}

\begin{enumerate}
\item Synchronisation nebenläufiger Transaktionen
\item Recovery nach Software- oder Hardwarefehlern
\end{enumerate}

\subsection{Read-Write-Modell \& Schedules}

\begin{itemize}
\item modelliert Datenbankzugriffe mit \texttt{read(A, x)} \& \texttt{write(x, A)}
\item Schedule eine zeitliche Vermischung von Operationen mehrerer Transaktionen
\item Problem: nicht jeder Schedule korrekt
\end{itemize}

\subsection{Typische Probleme ohne Nebeläufigkeitskontrolle}

\begin{itemize}
\item Lost Updates
\item Dirty Reads (Lesen nicht committeter Daten)
\item non-repeatable Reads (mehrmaliges Lesen liefert untersch. Ergebnisse)
\item Phantom Reads (erscheinen neuer Datensätze zw. 2 Lesevorgängen)
\end{itemize}

\subsection{Transaktionskonflikte}

entstehen bei Zugriffen versch. Tranaktionen auf dasselbe Objekt, wenn min. ein Schreibzugriff beteiligt ist

\begin{figure}[H]
\centering
\includegraphics[scale=.5]{pictures/transkon.png}
\caption{mögliche Transaktionskonflikte}
\end{figure}

\subsection{Serielle vs. serialisierbare Schedules}

\begin{itemize}
\item Serieller Schedule: maximale Isolation (Transaktionen nacheinander ausgeführt), schlechte Performance
\item Serialisierbar: nebenläufig, aber äquivalent zu einem seriellen Ablauf (S' äquivalent zu S vom Ergebnis her)
\begin{itemize}
\item Konflikt-Serialisierbarkeit (praxisrelevant, von DBMS unterstützt)
\item View-Serialisierbarkeit (theoretisch, kaum umsetzbar)
\end{itemize}
\end{itemize}

\subsection{Konflikt-Serialisierbarkeit}

2 Schedules $S_1$ \& $S_2$ sind konfliktäquivalent, wenn
\begin{itemize}
\item sie dieselben Transaktionen
\item mit denselben Operationen
\item \& derselben Reihenfolge aller konfliktierenden Operationen enthalten
\end{itemize}
\noindent
$\Rightarrow$ Nicht-konfliktierende Operationen dürfen vertauscht werden

\begin{figure}[H]
\centering
\includegraphics[scale=.4]{pictures/kssbsp.png}
\caption{Bsp. zur Entscheidung ob konfliktäquivalent}
\end{figure}

\noindent
\textbf{Schedule S ist konflikt-serialisierbar, wenn S zu einem seriellen Schedule konfliktäquivalent ist.}

\subsection{Prüfung auf Konflikt-Serialisierbarkeit}

\textbf{Präzedenzgraph (Abhängigkeitsgraph)}
\begin{enumerate}
\item für jede Transaktion ein Knoten
\item Kante $T_i \rightarrow T_j$, wenn $T_i$ vor $T_j$ konfliktierende Operation ausführt
\item kein Zyklus $\rightarrow$ konflikt-serialisierbar, Zyklus $\rightarrow$ nicht konflikt-serialisierbar
\end{enumerate}

\begin{figure}[H]
\begin{minipage}[t]{.5\textwidth}
\centering
\includegraphics[scale=.5]{pictures/pks1.png}
\end{minipage}
\hfill
\begin{minipage}[t]{.5\textwidth}
\centering
\includegraphics[scale=.5]{pictures/pks2.png}
\end{minipage}
\caption{links nicht konflikt-serialisierbar \& recht konflikt-serialisierbar}
\end{figure}

\subsection{Zurücksetzbare (recoverable) Transaktions-Schedules}

\begin{itemize}
\item Transaktion erst committen darf, nachdem alle Transaktionen,
deren Daten sie gelesen hat, ebenfalls committet haben
\item verhindert Cascading Rollbacks
\item Voraussetzung für korrektes Recovery
\end{itemize}

\subsection{Kaskadierende \& strikte Schedules}

\begin{itemize}
\item Nicht-recoverable: falsche Commit-Reihenfolge
\item Recoverable: korrekt, aber evtl. Rollbacks
\item Cascadeless: keine Dirty Reads
\item Strict: keine Lese-/Schreibzugriffe auf uncommittete Daten 
\end{itemize}

\subsection{Nebenläufigkeitskontrolle}

\begin{itemize}
\item Aufgabe des DBMS zur Sicherstellung von Isolation
\item Ziel: nur korrekte Schedules zulassen
\item praktische Umsetzung mit Locks
\end{itemize}

\subsubsection{Locks}

\begin{figure}[H]
\begin{minipage}[t]{.45\textwidth}
\begin{itemize}
\item S-Lock (Shared Lock): erlaubt Lesen, mehrere Transaktionen gleichzeitig
\item X-Lock (Exclusive Lock): Schreiben erlaubt, exklusiv
\item unlock
\end{itemize}
\end{minipage}
\hfill
\begin{minipage}[t]{.5\textwidth}
\vspace{-5mm}
\centering
\includegraphics[width=\linewidth]{pictures/lkm.png}
\caption{Lock-Kompatibilitätsmatrix}
\end{minipage}
\end{figure}

\subsubsection{Two-Phase-Locking (2PL) Protokoll}

\begin{itemize}
\item Wachstumsphase: Locks anfordern
\item Schrumpfphase: Locks freigeben
\item garantiert Konfliktserialisierbarkeit
\end{itemize}

\begin{figure}[H]
\centering
\includegraphics[scale=.5]{pictures/2pl.png}
\caption{2PL Veranschaulichung}
\end{figure}

\subsubsection{Striktes Two-Phase-Locking Protokoll}

\begin{figure}[H]
\begin{minipage}[t]{.45\textwidth}
\begin{itemize}
\item alle X-Locks erst bei Commit/Abort freigegeben
\item keine Dirty Reads, einfaches Recovery
\item Industriestandard
\end{itemize}
\end{minipage}
\hfill
\begin{minipage}[t]{.45\textwidth}
\vspace{-15mm}
\centering
\includegraphics[width=\linewidth]{pictures/s2pl.png}
\caption{S2PL Diagramm}
\end{minipage}
\end{figure}

\subsection{Isolationsstufen}

\begin{enumerate}
\item Read Uncommited: liest Daten, die noch nicht committet sind
\item Read Commited: liest nur committete Daten
\item Repeatable Read: gelesene Daten bleiben stabil während Transaktion
\item Seializable: wie ein serieller Schedule
\end{enumerate}

\begin{figure}[H]
\centering
\includegraphics[scale=.5]{pictures/isozsm.png}
\caption{Zusammenfassung der Stufen}
\end{figure}

\newpage

\subsection{Wiederherstellung (Recovery)}

Fehlertypen
\begin{itemize}
\item Transaktionsfehler (logisch)
\item Systemfehler (Hardware/Software)
\item Medienfehler (Speicher)
\end{itemize}
\noindent

\subsection{Recoverystrategien}

\subsubsection{Seitenersetzungsstrategien}

\begin{enumerate}
\item STEAL
\begin{itemize}
\item Seiten mit uncommitteten Änderungen dürfen auf die Festplatte geschrieben werden
\item Änderungen abgebrochener Transaktionen müssen \texttt{undo} werden
\end{itemize}
\item NO-STEAL
\begin{itemize}
\item Seiten mit uncommitteten Änderungen dürfen nicht geschrieben werden
\item Kein \texttt{undo} nötig
\end{itemize}
\end{enumerate}

\subsubsection{Propagierungsstrategien}

\begin{enumerate}
\item FORCE
\begin{itemize}
\item Geänderte Seiten werden beim Commit sofort auf die Festplatte geschrieben
\item Änderungen committeter Transaktionen sind sicher
\end{itemize}
\item NO-FORCE
\begin{itemize}
\item Geänderte Seiten müssen beim Commit nicht sofort geschrieben werden
\item Änderungen müssen ggf. \texttt{redo} werden
\end{itemize}
\end{enumerate}

\begin{figure}[H]
\centering
\includegraphics[scale=.5]{pictures/recstra.png}
\caption{Übersicht der Strats}
\end{figure}

\begin{itemize}
\item FORCE/NO STEAL: einfach, aber langsam
\item NO FORCE/STEAL: komplex aber schnell
\end{itemize}

\subsubsection{Seitenallokationsstrategien}

Wie schmutzige Seiten auf Sekundärspeicher zurückschreiben?

\begin{enumerate}
\item Direkte Allokation (nicht atomar)
\begin{itemize}
\item Jede Seite im Buffer ist genau einer Seite in der Datenbank zugeordnet
\item Buffer-Seite wird beim Auslagern auf die entsprechende Datenbankseite kopiert
\item alte Zustandr geht dabei verloren
\item Zur Wiederherstellung älterer Zustände ist zusätzliches Logging erforderlich
\end{itemize}
\item Indirekte Allokation (atomar)
\begin{itemize}
\item Für jede Buffer-Seite wird ein Zwillingsblock im stabilen Speicher reserviert
\item Buffer-Seite wird jeweils in den „älteren“ Zwillingsblock ausgelagert
\item Selbst im Fehlerfall ist der zuletzt konsistente Zustand verfügbar
\item Doppelter Speicherbedarf
\item Seitentabellen zur Abbildung zwischen flüchtigem und stabilem Speicher passen nicht vollständig in den Hauptspeicher
\end{itemize}
\end{enumerate}

\subsection{Logging}

\begin{enumerate}
\item physisches Logging: Speicherung der exakten physischen Änderungen an einer
Speichereinheit (z. B. einem Byte oder einer Seite)
\item logisches Logging: Speicherung der Operationen, die zu den Änderungen führen
\item physiologisches Logging: physisch auf Seitenebene, logisch innerhalb einer Seite
\end{enumerate}

\begin{figure}[H]
\begin{minipage}[t]{.5\textwidth}
\centering
\includegraphics[width=\linewidth]{pictures/dlog1.png}
\caption{zu loggende Infos}
\end{minipage}
\hfill
\begin{minipage}[t]{.5\textwidth}
\centering
\includegraphics[width=\linewidth]{pictures/dlog2.png}
\caption{Logstruktur}
\end{minipage}
\end{figure}

\subsection{Write-Ahead Logging}

\begin{itemize}
\item Alle Änderungen werden zuerst ins Log geschrieben, bevor Datenseiten auf die Festplatte dürfen
\item Commit erst erlaubt, wenn alle Log-Einträge dauerhaft gespeichert sind
\item Ermöglicht UNDO (für nicht-committete Transaktionen) und REDO (für committete Transaktionen)
\item Grundlage für STEAL + NO FORCE-Strategien
\item Industriestandard moderner DBMS
\end{itemize}

\subsection{Recoveryprozess}

\begin{enumerate}
\item Log-Analyse: Bestimmung von Gewinnern/Verlierern
\begin{itemize}
\item Gewinner mit (T, commit)
\item Verlierer ohne/mit (T,abort)
\end{itemize}
\item REDO-Phase: Änderungen committeter Transaktionen wiederherstellen
\begin{itemize}
\item Fall 1: $LSN_p \geq LSN_l$ $\Rightarrow$ keine Aktion
\item Fall 2: $LSN_p < LSN_l$ $\Rightarrow$ im Log-Eintrag gespeicherte REDO-Operation ausführen, $LSN_p$ durch $LSN_l$ ersetzen
\end{itemize}
\item UNDO-Phase: Änderungen nicht-committeter Transaktionen rückgängig machen
\end{enumerate}

\subsection{Idempotenz}

wichtig, wenn das DBMS beim Neustart und des Recoveryprozesses abschmiert

\begin{enumerate}
\item REDO
\begin{itemize}
\item $LSN_p \geq LSN_l$ $\Rightarrow$ wurde bereits angewendet, es ist also nichts zu tun
\item $LSN_p < LSN_l$ $\Rightarrow$ wurde noch nicht angewendet
\end{itemize}
\item UNDO
\begin{itemize}
\item Speicherung zusätzlicher Infos im Compensation Log Records (CLRs)
\item Für jede ausgeführte UNDO-Operation erzeugt ein CLR mit einer eindeutigen LSN
\item Falls das DBMS während des UNDO ausfällt, undo redoen
\item Jede UNDO-Operation, die bereits während der REDO-Phase ausgeführt wurde, wird in
der anschließenden UNDO-Phase übersprungen
\item UndoNxtLSN, um auf die der aktuellen zu kompensierenden Operation
vorhergehende UNDO-Operation zu verweisen
\end{itemize}
\end{enumerate}

\section{Storage \& File Structures}

\subsection{Storage vs. Memory}

\begin{figure}[H]
\begin{minipage}[t]{.45\textwidth}
\textbf{Storage (HDD, SSD, etc.)}
\begin{itemize}
\item nicht-flüchtig, große Kapazität, günstig
\item hohe Latenz ($\mu$s -ms)
\end{itemize}
\end{minipage}
\hfill
\begin{minipage}[t]{.45\textwidth}
\textbf{Memory (DRAM, SRAM)}
\begin{itemize}
\item flüchtig, sehr schnell (ns)
\item begrenzte Kapazität, teuer
\end{itemize}
\end{minipage}
\end{figure}
\noindent
$\Rightarrow$ DBMS müssen mit einem großen Performance-Gap zw. Storage \& Memory umgehen.

\subsection{Klassifikation physischer Speichermedien}

\begin{itemize}
\item \textbf{Performance:} Zugriffszeit, Kosten pro Dateneinheit
\item \textbf{Zuverlässigkeit:} Verhalten bei Stromausfall/Systemabsturz, physischer Ausfall von Medien
\end{itemize}

\subsection{Speichermedien}

\begin{figure}[H]
\begin{minipage}[t]{.45\textwidth}
\textbf{Cache}
\begin{itemize}
\item extrem schnell, sehr teuer, flüchtig
\item Hardware-/OS-verwaltet
\end{itemize}
\noindent
\textbf{Hauptspeicher}
\begin{itemize}
\item direkt Verarbeitung durch CPU
\item zu klein für komplette DB
\item Trend: persistenter Hauptspeicher (z.B. Intel Optane)
\end{itemize}
\noindent
\textbf{Flash/Magnetische Festplatten}
\begin{itemize}
\item zentraltes Medium für DB-Speicherung
\item Direktzugriff, nicht flüchtig
\end{itemize}
\end{minipage}
\hfill
\begin{minipage}[t]{.45\textwidth}
\textbf{Optische Medien}
\begin{itemize}
\item CD/DVD, WORM
\item vor allem für Archivierung
\end{itemize}
\noindent
\textbf{Tape}
\begin{itemize}
\item sehr hohe Kapazität, sequenzieller Zugriff
\item Backup \& Archiv
\end{itemize}
\end{minipage}
\end{figure}

\subsubsection{Speicherhierarchie}

\begin{figure}[H]
\begin{minipage}[t]{.45\textwidth}
\begin{itemize}
\item \textbf{Primärspeicher:} Cache, RAM (schnell, flüchtig)
\item \textbf{Sekundärspeicher:} Festplatten (nicht-flüchtig)
\item \textbf{Tertiärspeicher:} Band, optische Medien (langsam)
\end{itemize}
\end{minipage}
\hfill
\begin{minipage}[t]{.45\textwidth}
\centering
\vspace{-10mm}
\includegraphics[width=\linewidth]{pictures/speicherhierarchi.png}
\caption{Speicherhierarchie}
\end{minipage}
\end{figure}

\subsubsection{Metriken für magnetische Festplatten}

\begin{itemize}
\item Zugriffszeit: Suchzeit + Rotationszeit
\item Datenübertragungsrate
\item MTTF (Mean Time To Failure)
\end{itemize}

\subsubsection{Rotationsverzögerung \& Seek Time}

\begin{itemize}
\item $R_{max} = \frac{60 \cdot 1000}{\text{RPM}}$
\item $R_{avg} = 0,5 \cdot R_{max}$
\item Seek Time: Bewegung des Schreib-/Lesekopfs zur Spur 
\end{itemize}

\begin{figure}[H]
\centering
\includegraphics[scale=.5]{pictures/seektime.png}
\caption{Seek Time}
\end{figure}

\subsubsection{Optimierung des Festplattenzugriffs}

\textbf{Block}
\begin{itemize}
\item kleinste I/O-Einheit
\item Übertragung zw. Disk \& RAM
\end{itemize}
\noindent
\textbf{Dateiorganisation}
\begin{itemize}
\item DB als Dateien $\rightarrow$ Seiten $\rightarrow$ Datensätze
\item Ziel: Minimierung von I/O durch räumliche Nähe verwandter Daten
\end{itemize}

\subsection{Seiten \& Speicherzugriff im DBMS}

\begin{itemize}
\item Einheit für Allokation \& Transfer
\item enthalten Tupel, Indizes, Logs etc.
\item Ziel: Minimierung der Seitentransfers durch Caching im RAM
\end{itemize}

\subsection{Lokalität}

\begin{itemize}
\item Räumliche Lokalität: zsmgehörige Seiten physisch nahe speichern
\item Zeitliche Lokalität: Seiten möglichst lange im Hauptspeicher halten
\end{itemize}

\subsection{Festplatten-orientierte DBMSs}

\begin{itemize}
\item gesamter DB-Zustand liegt auf Festplatte
\item Buffer Pool
\begin{itemize}
\item Teil des Hauptspeichers
\item enthält Kopien von Festplattenseiten
\end{itemize}
\item Buffer Pool Manager: lädt, ersetzt \& schreibt Seiten zurück
\end{itemize}

\begin{figure}[H]
\begin{minipage}[t]{.45\textwidth}
\centering
\includegraphics[width=\linewidth]{pictures/bp1.png}
\end{minipage}
\hfill
\begin{minipage}[t]{.45\textwidth}
\centering
\includegraphics[width=\linewidth]{pictures/bp2.png}
\end{minipage}
\caption{Laden einer Seite}
\begin{minipage}[t]{.45\textwidth}
\centering
\includegraphics[width=\linewidth]{pictures/bp3.png}
\end{minipage}
\hfill
\begin{minipage}[t]{.45\textwidth}
\centering
\includegraphics[width=\linewidth]{pictures/bp4.png}
\end{minipage}
\caption{Ersetzen einer Seite}
\end{figure}

\subsection{Buffer Pool Manager - Arbeitsweise}

\begin{enumerate}
\item Seite im Buffer $\rightarrow$ Adresse zurückgeben
\item Seite nicht im Buffer $\rightarrow$ Platz schaffen (Eviction)
\item Dirty Pages werden zurückgeschrieben
\item Seite wird von Disk geladen
\end{enumerate}

\subsection{Seitenersetzungsstrategien}

\begin{itemize}
\item LRU (Least Recently Used)
\begin{itemize}
\item ersetzt am längsten nicht genutzte Seite
\item gut für viele Workloads
\item schlecht bei wiederholten sequentiellen Scans
\end{itemize}
\item Praxis: Kombination mit Query-Optimizer-Hinweisen
\end{itemize}

\subsection{Dateiorganisation}

\begin{itemize}
\item DB = Dateien $\rightarrow$ Seiten $\rightarrow$ Datensätze $\rightarrow$ Felder
\item einfacher Ansatz: 
\begin{itemize}
\item feste Datensatzlänge
\item eine Relation pro Datei
\end{itemize}
\end{itemize}

\subsection{Datensätze fester Länge}

\begin{itemize}
\item direkter Zugriff über Offset
\item Löschstrategien: markieren, verschieben, Austausch mit letztem Datensatz, Free Lists
\end{itemize}

\subsection{Free Lists}

\begin{itemize}
\item Verwaltung gelöschter Datensätze
\item Verkettete Liste freier Plätze
\item reduziert Fragmentierung
\end{itemize}

\subsection{Datensätze variabler Länge}

\begin{figure}[H]
\begin{minipage}[t]{.45\textwidth}
\begin{itemize}
\item \textbf{Gründe:}
\begin{itemize}
\item unterschiedliche Record-Typen
\item variable Felder (VARCHAR)
\end{itemize}
\end{itemize}
\end{minipage}
\hfill
\begin{minipage}[t]{.45\textwidth}
\begin{itemize}
\item \textbf{Herausforderungen:}
\begin{itemize}
\item Fragmentierung
\item Update erfordern Verschieben
\item Überlauf auf andere Seiten
\end{itemize}
\end{itemize}
\end{minipage}
\end{figure}

\subsubsection{Ansätze für variable Datensätze}

\begin{itemize}
\item End-of-Record Marker
\item Fild Delimiters
\begin{figure}[H]
\centering
\includegraphics[scale=.75]{pictures/fielde.png}
\caption{erfordert Scan, um Wert des n-ten Feldes zu erhalten; ein Feld für NULL-Wert}
\end{figure}
\item Array of Field Offsets
\begin{itemize}
\item direkter Feldzugriff
\item saubere Null-Verwaltung
\end{itemize}
\begin{figure}[H]
\centering
\includegraphics[scale=.6]{pictures/afo.png}
\caption{Start-/End-Point eines selben Feldes zeigen auf dieselbe Adresse}
\end{figure}
\end{itemize}

\subsubsection{Slotted Pages}

\begin{itemize}
\item Slot Dir am Seitenende
\item Datensätze können innerhalb der Seite verschoben werden
\item Vorteile: stabile RIDs, effiziente Inserts/Deletes
\end{itemize}

\begin{figure}[H]
\begin{minipage}[t]{.33\textwidth}
\centering
\includegraphics[width=\linewidth]{pictures/slotp1.png}
\end{minipage}
\hfill
\begin{minipage}[t]{.33\textwidth}
\centering
\includegraphics[width=\linewidth]{pictures/slotp2.png}
\end{minipage}
\hfill
\begin{minipage}[t]{.33\textwidth}
\centering
\includegraphics[scale=.3]{pictures/slotp3.png}
\end{minipage}
\caption{Löschen, einfügen \& erweitern}
\end{figure}

\subsubsection{Datensatz-Identifikatoren (RID/TID)}

\begin{itemize}
\item eindeutige Identifikation: Seiten-ID, Slot-ID
\item Grundlage für Referenzen \& Indizes
\end{itemize}

\begin{figure}[H]
\centering
\includegraphics[scale=.5]{pictures/di.png}
\caption{RID}
\end{figure}

\subsection{Datenbank Workloads}

\begin{itemize}
\item On-Line Transaction Processing (OLTP): viele kleine, schreibintensive Operationen
\item On-Line Analytical Processing (OLAP): komplexe, leselastige Scans
\item Hybrid Transaction + Analytical Processing (HTAP): Kombi aus beiden
\end{itemize}

\begin{figure}[H]
\centering
\includegraphics[scale=.35]{pictures/dw.png}
\caption{Choose what is best}
\end{figure}

\subsection{Datenspeichermodelle}

\begin{itemize}
\item NSM (Row Store)
\item DSM (Column Store)
\item Pax (Hybrid)
\item abhängig von Workload
\end{itemize}

\subsubsection{N-ary Storage Mode (NSM)}

\begin{figure}[H]
\begin{minipage}[t]{.45\textwidth}
\begin{itemize}
\item alle Attribute eines Tupels zsm
\item ideal für OLTP
\item Vorteile: schnelle Inserts/Updates
\item Nachteile: schlechte Performance bei Attributscans, schlechte Kompression
\end{itemize}
\end{minipage}
\hfill
\begin{minipage}[t]{.45\textwidth}
\centering
\vspace{-25mm}
\includegraphics[scale=.45]{pictures/nsm.png}
\caption{Row Store}
\end{minipage}
\end{figure}

\subsubsection{Decomposition Storage Model (DSM)}

\begin{figure}[H]
\begin{minipage}[t]{.45\textwidth}
\begin{itemize}
\item spaltenweise Speicherung
\item ideal für OLAP
\item Vorteile: weniger I/O, gute Kompression
\item Nachteile: teuer für Punktabfagen, Tuple Stitching notwendig
\end{itemize}
\end{minipage}
\hfill
\begin{minipage}[t]{.45\textwidth}
\centering
\vspace{-10mm}
\includegraphics[scale=.35]{pictures/dsm1.png}
\\
\includegraphics[scale=.35]{pictures/dsm2.png}
\caption{Col Store}
\end{minipage}
\end{figure}

\subsubsection{Partition Attributes Across (PAX) Storage Model}

\begin{figure}[H]
\begin{minipage}[t]{.45\textwidth}
\vspace{10mm}
\begin{itemize}
\item Hybrid aus NSM \& DSM
\item vertikale Partitionierung innerhalb einer Seite
\item Ziel: gute Cache-Lokalität, Vorteile spaltenorientierter Verarbeitung
\end{itemize}
\end{minipage}
\hfill
\begin{minipage}[t]{.45\textwidth}
\centering
\vspace{0mm}
\includegraphics[scale=.35]{pictures/pax.png}
\caption{PAX}
\end{minipage}
\end{figure}

\subsection{Datenbankkompression}

\begin{itemize}
\item Motivation: I/O ist Hauptengpass
\item Anforderungen: verlusfrei, feste Länge, späte Dekompression
\item Granularität: Block, Tupel, Attribut, Spalte
\end{itemize}

\subsection{Spaltenorientierte Kompression}

\begin{itemize}
\item Run-Length Encoding
\item Delta Encoding
\item Dictionary Encoding
\item Bit-Packing
\item (Bitmap Encoding)
\end{itemize}

\subsection{Suche nach Tupeln}

\begin{itemize}
\item naiver Ansatz: Full Table Scan
\item Problem: langsam, teuer
\item Lösung: Indexstrukturen
\end{itemize}

\subsection{Indexstrukturen - Grundlangen}

\begin{itemize}
\item Index = Suchschlüssel $\rightarrow$ Datenzeiger
\item deutlich kleiner als Datendatei
\item Typen: sortierte Indizes, Hash-Indizes
\end{itemize}

\begin{figure}[H]
\centering
\includegraphics[scale=.5]{pictures/indexdatei.png}
\caption{Aufbau einer Indexdatei}
\end{figure}

\noindent
\textbf{Evaluationskriterien für Indizes}
\begin{itemize}
\item Unterstützte Zugriffstypen
\item Such-, Insert-, Delete-Kosten
\item Speicher- und Pflegeaufwand
\end{itemize}

\subsection{Primär- vs Sekundärindizes}

\begin{figure}[H]
\begin{minipage}[t]{.45\textwidth}
\textbf{Primär}
\begin{itemize}
\item Definiert physische Sortierung
\item Maximal einer pro Relation
\end{itemize}
\end{minipage}
\hfill
\begin{minipage}[t]{.45\textwidth}
\textbf{Sekundär}
\begin{itemize}
\item Andere Suchschlüssel
\item Bucket-Struktur für Mehrfachtreffer
\end{itemize}
\end{minipage}
\end{figure}

\subsection{ISAM (Index-Sequential Access Method)}

\begin{itemize}
\item Sortierte Datenseiten + Indexseiten
\item Gute Unterstützung für Bereichsanfragen
\item Problem: Starre Struktur bei vielen Inserts
\item ähnlich zu B/$B^+$-Baum bei Einfügen, Löschen \& Verschieben
\end{itemize}

\begin{figure}[H]
\centering
\includegraphics[scale=.5]{pictures/isam.png}
\caption{ISAM}
\end{figure}

\subsection{Hashing vs. Bäume}

\begin{itemize}
\item Hashing benötigt weniger Seitenzugriffe, aber Performance kann sich verschlechtern, wenn Funktion schwach
\item Hashing ranodmisiert Schlüsselverteilung $\rightarrow$ geringe räumliche Lokalität
\item unterstützt weder Bereichsanfragen noch Präfixanfragen
\item meist $B^+$-Baum Standard-Indexstruktur in DBMS
\end{itemize}

\subsection{Indexe in SQL}

\textbf{Syntax (allgemeinste Form)}
\begin{lstlisting}[language=SQL]
CREATE [UNIQUE] INDEX <INDEX name> ON <relation name> (<list of attributes>);
DROP INDEX <INDEX name>;
\end{lstlisting}

\begin{itemize}
\item SQL bietet viele erweiterte Indexoptionen (z.B. Bitmap-, funktionsbasierte, partitionierte Indizes)
\item Indexe werden standardmäßig aufsteigend angelegt
\item Primärschlüssel erzeugen automatisch einen Index
\end{itemize}

\begin{lstlisting}[language=SQL]
CREATE INDEX city_name_idx ON CITY(name);
\end{lstlisting}

\end{document}