\documentclass[12pt,a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage[german]{babel}
\usepackage[T1]{fontenc}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage{float}              
\usepackage{caption}
\usepackage{adjustbox}
\usepackage{lmodern}
\usepackage{fourier}
\usepackage[hidelinks]{hyperref}
\usepackage{listings}
\usepackage{xcolor}
\usepackage[left=2cm,right=2cm,top=2cm,bottom=2cm]{geometry}

\lstset{
  basicstyle=\ttfamily\small,
  keywordstyle=\color{blue}\bfseries,
  commentstyle=\color{gray},
  stringstyle=\color{teal},
  frame=single,
  breaklines=true,
  showstringspaces=false
}

\captionsetup[figure]{name=Abb.}

\begin{document}

\tableofcontents
\newpage

\section{Grundlagen Datenbankensysteme}

\subsection{Probleme alternativer Programme}

\begin{itemize}
\item Redundanzen \& Inkonsistenzen
\item eingeschränkter Zugriff auf Daten
\item Probleme bei Mehrbenutzerzugriff
\item Datenverluste, Integritäts- \& Sicherheitsprobleme
\item hoher Entwicklungsaufwand
\end{itemize}

\subsection{Was ein Datenbanksystem ist}

\begin{figure}[H]
\begin{minipage}[t]{0.45\textwidth}
\begin{itemize}
\item \textbf{DBS} = Datenbank (DB) \& Datenbankmanagementsystem (DBMS)
\begin{itemize}
\item \textbf{Datenbank:} Sammlung verknüpfter, persistenter Daten (z. B. Uni mit Studierenden, Kursen usw.)
\item \textbf{DBMS:} Software zur Speicherung, Verwaltung \& Zugriff auf diese Daten
\end{itemize}
\item \textbf{Zweck:} Einheitliche Verwaltung, Zugriff, Integrität, Sicherheit, Transaktionen, Wiederherstellung
\end{itemize}
\end{minipage}
\hfill
\begin{minipage}[t]{0.45\textwidth}
\centering
\vspace{5mm}
\adjustbox{valign=c}{\includegraphics[scale=0.35]{pictures/FunkDBS.png}}
\caption{Funktion Datenbanksystem}
\end{minipage}
\end{figure}

\subsection{Codds 12 Regeln (Zweck eines DBS)}

\begin{itemize}
\item einheitliche Datenintegration
\item effizienter Zugriff über Datenbanksprachen
\item Metadatenkatalog
\item versch. Benutzer-/Anwendungssichten
\item Integritätsbedingungen von DBMS sichergestellt
\item Sicherheitsmechanismen für Schutz der Daten
\item Transaktionen, Synchronisation \& Widerherstellung nach BSOD
\item Unterstützung für Ad-hoc Anfragen \& Schnittstellen
\end{itemize}

\subsection{Datenabstraktion \& Sichten}

\begin{itemize}
\item Drei Ebenen:
\begin{enumerate}
\item \textbf{physical level:} Spreicherung \& Strukturen
\item \textbf{logical level:} Datenmodell, Entities \& Beziehungen
\item \textbf{view level:} Benutzer- \& Anwendungssicht
\end{enumerate}
\item \textbf{Ziel:} Abstraktion \& Datenunabhängigkeit
\begin{itemize}
\item \textbf{Physische Datenunabhängigkeit:} Speicher ändern ohne Logikänderung
\item \textbf{Logische Datenunabhängigkeit:} Logik ändern ohne Anwendungscode anzupassen
\end{itemize}
\end{itemize}

\begin{figure}[H]
\centering
\includegraphics[scale=0.5]{pictures/Datensicht.png}
\caption{Sicht auf Daten}
\end{figure}

\subsection{Schemata \& Instanzen}

\begin{itemize}
\item Instanz = Inhalt
\item Schema = Struktur
\begin{itemize}
\item konzeptionell/logisch: Grundlage für Design
\item Sicht (externes Schema): während Anforderungsanalyse definiert
\item physisch: Speicherstrukturen mit Relationen verbunden
\end{itemize}
\end{itemize}

\subsection{Datenmodelle}

\begin{itemize}
\item \textbf{konzeptionell}: Entity Relationship (ER)-Modell, semantisch, objektorientiert
\item \textbf{logisch}: relational, objektrelational, hierarchisch, Netzwerk, XML/JSON
\end{itemize}

\subsection{Datenbanksprachen}

\begin{itemize}
\item \textbf{DDL (Data Definition Language):} \\
definiert Schemata \& Metadaten (z.B. CREATE TABLE)
\item \textbf{DML (Data Manipulation Language):} \\
Zugriff \& Veränderung der Daten (z.B. SELECT, INSERT)
\begin{itemize}
\item prozedural: wie abgefragt
\item deklarativ: was abgefragt (SQL), nicht prozedural
\end{itemize}
\end{itemize}

\subsection{Anwendungsarchitekturen}

\begin{itemize}
\item basiert auf Client-Server-Modell
\item Trennung der Funktionalitäten einer Anwendung:
\begin{itemize}
\item Benutzeroberfläche \& Interaktion
\item Anwendungslogik (Business Logic)
\item Datenverwaltungsfunktionalität (Speicherung, Verwaltung, Zugriff)
\end{itemize}
\end{itemize}

\begin{figure}[H]
\centering
\begin{minipage}[t]{0.32\textwidth}
\centering
\includegraphics[width=\textwidth]{pictures/cs.png}
\caption{Client-Server-Modell}
\end{minipage}
\hfill
\begin{minipage}[t]{0.32\textwidth}
\centering
\includegraphics[width=\textwidth]{pictures/2s.png}
\caption{2-schichtige Architektur}
\end{minipage}
\hfill
\begin{minipage}[t]{0.32\textwidth}
\centering
\includegraphics[width=\textwidth]{pictures/3s.png}
\caption{3-schichtige Architektur}
\end{minipage}
\end{figure}

\section{Relationales Modell}

\subsection{Grundlagen}

\begin{itemize}
\item Erfinder: Edgar F. Codd (IBM, 1970), Turing Award 1981
\item Bedeutung: Grundlage fast aller modernen Datenbanksysteme \\
(z. B. Oracle, MySQL, PostgreSQL)
\item Kernidee: Daten in Relationen (Tabellen) gespeichert, mit starker mathematischer Basis
\end{itemize}

\subsection{Zentrale Begriffe}

\begin{itemize}
\item \textbf{Domäne:} Wertebereich eines Attributs (Zahl, Farbe, String, Datum, usw.)
\item \textbf{Kartesisches Produkt:} Kombination aller möglichen Werte aus Menge
\item \textbf{Relation:} Menge von n-Tupeln, Teilmenge vom kartesischem Produkt
\item \textbf{Attribut:} Spalte einer Relation
\item \textbf{Grad (Stelligkeit):} Anzahl der Attribute
\item \textbf{Kardinalität:} Anzahl an Tupeln der Relation
\item \textbf{Wichtiges:} Reihenfolge egal, aber keine Duplikate erlaubt
\end{itemize}

\subsection{Relationen- \& Datenbankschema}

\begin{itemize}
\item \textbf{Relationsschema:} legt Struktur der Relation fest \\
$\rightarrow$ z.B. Student(StudId: number, StudName: string, Major: string)
\item \textbf{Instanz eines Datenbankschemas/Relationeninstanz r(R):} Sammlung von Relationen
\item \textbf{Geordnetes Schema:} Position der Attribute relevant
\item \textbf{Ungeordnetes Schema:} Attribute über Namen referenziert
\end{itemize}

\begin{figure}[H]
\centering
\includegraphics[scale=0.55]{pictures/bspRelationsinstanz.png}
\caption{Beispiel einer Relationsinstanz}
\end{figure}

\subsection{Integritätsbedingungen}

Stellt Korrektheit, Konsistenz \& Gültigkeit der Daten sicher:
\begin{itemize}
\item \textbf{Primärschlüssel:} Eindeutiger Identifier für jedes Tupel
\item \textbf{Fremdschlüssel:} Verweist auf Primärschlüssel einer anderen Relation
\item \textbf{Eindeutigkeit (UNIQUE)} \& \textbf{NOT NULL}
\item \textbf{Referenzielle Integrität:} Keine defekten Verweise (Fremdschlüssel muss existieren oder NULL sein)
\end{itemize}

\textbf{$\Rightarrow$ Muss unbedingt für jede Instanz eines Relationsschemas erfüllt sein:}
\begin{itemize}
\item bei Definition des Schemas angegeben
\item vom DBMS bei Änderungen an Relationen überprüft
\end{itemize}

\subsection{Schlüsseltypen}

\begin{itemize}
\item \textbf{Schlüssel $R(S \subseteq R)$:} eindeutig \& minimal
\item \textbf{Superschlüssel $S \subseteq R$:} eindeutig, aber nicht minimal
\item \textbf{zsmgesetzter Schlüssel:} Kombination mehrerer Attribute
\item \textbf{Kanditatenschlüssel:} mögliche Schlüssel
\item \textbf{Primärschlüssel:} ausgewählter Kandidatenschlüssel
\item \textbf{Fremdschlüssel:} verweist auf Primärschlüssel referenzierter Relation
\end{itemize}

\begin{figure}[H]
\begin{minipage}[t]{0.45\textwidth}
\centering
\includegraphics[scale=0.4]{pictures/sd1.png}
\caption{Tupel in A ohne Partner in B unzulässig}
\end{minipage}
\hfill
\begin{minipage}[t]{0.5\textwidth}
\centering
\includegraphics[scale=0.4]{pictures/sd2.png}
\caption{Löschen von Tupel in B nicht möglich, wenn referenziert}
\end{minipage}
\end{figure}

\subsection{SQL Data Definition Language (DDL)}

\textbf{Definiert Relationen \& Integritätsbedingungen:}
\begin{lstlisting}[language = SQL]
CREATE TABLE Student (
  StudId INTEGER PRIMARY KEY,
  StudName VARCHAR(50) NOT NULL,
  Major VARCHAR(50)
);
\end{lstlisting}

\subsubsection{Grundlegende Datentypen}

\begin{itemize}
\item \textcolor{blue}{INTEGER} (auch: \textcolor{blue}{INTEGER4}, \textcolor{blue}{INT})
\item \textcolor{blue}{SMALLINT} (auch: \textcolor{blue}{INTEGER2})
\item \textcolor{blue}{FLOAT} und \textcolor{blue}{DOUBLE}
\item \textcolor{blue}{DECIMAL(p,q)} und \textcolor{blue}{NUMERIC(p,q)} mit $p$ = Gesamtanzahl der Stellen und $q$ = Anzahl der Nachkommastellen
\item \textcolor{blue}{CHARACTER(n)}, \textcolor{blue}{CHAR(n)} – Zeichenketten fester Länge $n$
\item \textcolor{blue}{VARCHAR(n)} – Zeichenketten variabler Länge (bis maximal $n$)
\item \textcolor{blue}{DATE}, \textcolor{blue}{TIME}, \textcolor{blue}{TIMESTAMP} – für Datums- und Zeitangaben
\end{itemize}

\subsubsection{Wichtige SQL-Constraints}

\begin{itemize}
\item  \textcolor{blue}{PRIMARY KEY}: zsmgesetzter Primärschlüssel ($A_1, A_2, ...$) 
\item \textcolor{blue}{UNIQUE}: zsmgesetzter Kandidatenschlüssel ($A_1, A_2, ...$) 
\item \textcolor{blue}{NOT NULL}: Attributwert undefiniert unzulässig
\item \textcolor{blue}{DEFAULT} $w_1$: $w_1$ als Standard genutzt 
\item \textcolor{blue}{CHECK} f: überprüft bei jedem Einfügen Formel f
\item \textcolor{blue}{REFERENCES} $t_1(a_1)$: Verweis Attribut $a_1$ auf Tabelle $t_1$
\item Beispiel für Fremdschlüssel:
\begin{lstlisting}[language = SQL]
FOREIGN KEY (courseId, semester) REFERENCES Course
\end{lstlisting}
\item \textcolor{blue}{ON DELETE CASCADE}: \\
Löschen eines Tupels in B führt zum Löschen aller referenzierenden Tupel in A
\item \textcolor{blue}{ON UPDATE CASCADE}: \\
Änderung eines Tupels in B führt zur automatischen Änderung der referenzierenden Tupel in A
\item \textcolor{blue}{ON DELETE SET NULL}: \\
\glqq Herrenlose Referenzen\grqq ~in A werden auf \textcolor{blue}{NULL} gesetzt
\end{itemize}

\subsubsection{Änderung an Tabellen}

\begin{itemize}
\item \textcolor{blue}{DROP TABLE} t1: löscht Tabelle
\item \textcolor{blue}{ALTER TABLE} ... \textcolor{blue}{ADD}: fügt Attribut hinzu
\item \textcolor{blue}{ALTER TABLE} ... \textcolor{blue}{DROP}: entfernt Attribut
\item \textcolor{blue}{ALTER TABLE} ... \textcolor{blue}{MODIFY}: ändert Attributdefinition
\end{itemize}

\section{Relationale Algebra}

\subsection{Anfragesprachen}

\begin{itemize}
\item Anfragesprache (QL) ermöglicht Daten aus Datenbank auszulesen \& manipulieren
\item relationale Algebra $\rightarrow$ prozedural (SQL)
\item relationales Kalkül $\rightarrow$ deklarativ (QBE, Query-By-Example)
\end{itemize}

\subsection{Basisoperationen der relationalen Algebra}

\textbf{Unäre Operatoren}
\begin{itemize}
\item Selektion $\sigma_P(r)$: filtert Tupel nach Bedingung \\
r $\rightarrow$ Relation (Name) \\
P $\rightarrow$ Formel der Aussagenlogik: <Attribut> = <Attribut> oder <Konstante>
\item Projektion $\pi_{A_1,...,A_k}(r)$: wählt Spalte aus, entfernt Duplikate \\
$A_1,...,A_k$ $\rightarrow$ Attribute \\
Kardinalität: $\mid \pi_{A_1,...,A_k}(r) \mid \ll \mid r \mid$
\item Umbenennung $\phi$: benennt Relationen oder Attribute um \\
$phi_x(E)$ $\rightarrow$ Ausdruck E unter neuem Namen x
\end{itemize}

\noindent
\textbf{Binäre Operatoren}
\begin{itemize}
\item Vereinigung $\cup$: Tupel aus beiden Relationen
\item Differenz $-$: wie das logische \glqq Ohne\grqq zu verstehen
\item Kartesisches Produkt $\times$: Kombi von Tupeln aus r \& s
\end{itemize}

\begin{figure}[H]
\begin{minipage}[t]{.33\textwidth}
\centering
\includegraphics[scale=.25]{pictures/verein.png}
\caption{Vereinigung}
\end{minipage}
\hfill
\begin{minipage}[t]{.33\textwidth}
\centering
\includegraphics[scale=.25]{pictures/diff.png}
\caption{Differenz}
\end{minipage}
\hfill
\begin{minipage}[t]{.33\textwidth}
\centering
\includegraphics[scale=.25]{pictures/kat.png}
\caption{Kartesiches Produkt}
\end{minipage}
\end{figure}

\subsection{Zusätzliche Operatoren}


\begin{itemize}
\item Schnittmenge $\cap$: gemeinsame Tupel beider Relationen
\begin{figure}[H]
\centering
\includegraphics[scale=.3]{pictures/schnitt.png}
\end{figure}
\item Division $\div$: für \glqq für alle\grqq -Anfragen
\begin{figure}[H]
\centering
\includegraphics[scale=.3]{pictures/div.png}
\end{figure}
\item natürlicher Verbund (Join) $\bowtie$: verbindet Relationen über gleiche Attribute
\begin{figure}[H]
\begin{minipage}[t]{.5\textwidth}
\centering
\includegraphics[scale=.3]{pictures/join1.png}
\caption{Equi-Verbund (Join) mit selben Attribut}
\end{minipage}
\hfill
\begin{minipage}[t]{.5\textwidth}
\centering
\includegraphics[scale=.35]{pictures/join2.png}
\caption{Join ohne selbem Attribut}
\end{minipage}
\end{figure}
\item Theta-Verbung $\bowtie_C$: verbindet Relationen nach beliebiger Bedingung
\begin{figure}[H]
\centering
\includegraphics[scale=.35]{pictures/theta.png}
\end{figure}
\newpage
\item Outer-Joins: behalten auch Tupel ohne Partner
\begin{figure}[H]
\begin{minipage}[t]{.45\textwidth}
\centering
\includegraphics[scale=.3]{pictures/fullouter.png}
\caption{Full-Outer Join}
\end{minipage}
\hfill
\begin{minipage}[t]{.45\textwidth}
\centering
\includegraphics[scale=.3]{pictures/leftrightouter.png}
\caption{Left- \& Right-Outer Join}
\end{minipage}
\end{figure}
\end{itemize}

\subsection{Gruppierung \& Aggregation}

\begin{itemize}
\item Gruppierung: Gruppieren von Tupeln nach gemeinsamen Attributwerten
\item Aggregation: Anwenden einer Funktion auf jede Gruppe (z. B. count, avg, sum, min, max)
\item Notation :$\gamma_{A_1,...A_n;F_1,...F_n}(r)$ \\
$A_i \rightarrow$ Attribut \\
$F_I \rightarrow$ Aggregatfunktion
\end{itemize}

\begin{figure}[H]
\centering
\includegraphics[scale=.5]{pictures/gruppaggr.png}
\caption{Beispielanfrage}
\end{figure}

\subsection{Graphische Darstellung relationaler Algebra-Ausdrücke}

\begin{figure}[H]
\begin{minipage}[t]{.45\textwidth}
\begin{itemize}
\item Darstellung als Baum
\item Knoten = Operatoren (Ausdrücke)
\item Kanten = Datenfluss (Relationen)
\end{itemize}
\end{minipage}
\hfill
\begin{minipage}[t]{.45\textwidth}
\centering
\vspace{-10mm}
\adjustbox{valign=c}{\includegraphics[scale=.3]{pictures/grafalg.png}}
\caption{Beispieldarstellung}
\end{minipage}
\end{figure}

\newpage

\section{Relationenkalkül}

\textbf{Ziel:} Datenbankabfragen mittels des Kalküls formulieren \\
\textbf{Unterschied zur Relationenalgebra:} hier deklarativ, Fokus auf das \glqq Was\grqq

\subsection{Tupelkalkül (TRC)}

\begin{itemize}
\item Edgar F. Codd, als Teil des relationalen Modells
\item Basis vieler Abfragesprachen (QUEL, SQL)
\item Ausdrucksform: $\{t \mid \Psi(t)\}$
\item t: Tupevariable
\item $\Psi(t)$: logische Bedingung, die erfüllt sein muss
\end{itemize}

\noindent
\textbf{Bestandteile}

\begin{itemize}
\item Atome:
\begin{itemize}
\item $R(t)$: t is Tupel aus Relation R
\item $t.A \Theta s.B$ oder $t.A \Theta c$
\end{itemize}
\item Formeln:
\begin{itemize}
\item Logische Operatoren ($\neg, \vee, \wedge$)
\item Quantoren ($\exists, \forall$)
\item Implikation ($\rightarrow$)
\item Jedes Atom ist auch eine Formel!
\end{itemize}
\end{itemize}

\begin{figure}[H]
\centering
\includegraphics[scale=.4]{pictures/bspformeltrc.png}
\caption{Beispielanfragen TRC}
\end{figure}

\subsection{Semantik}

\begin{itemize}
\item Tupelvariablen: konkrete Tupel
\item Formeln: Wahrheitswerte
\item Ausdrücke: Relationen
\item Quantoren
\begin{itemize}
\item $\exists$: OR-Verknüpfung
\item $\forall$: AND-Verknüpfung
\end{itemize}
\end{itemize}

\subsection{Sichere Ausdrücke}

\begin{itemize}
\item Ohne Einschränkung können unendliche Ergebnisse entstehen
\item Sichere Ausdrücke liefern nur endliche, berechenbare Ergebnisse $\rightarrow$ realistisch für Datenbanken
\end{itemize}

\subsection{Domänenkalkül (DRC)}

\begin{itemize}
\item Variablen für einzelne Attribute
\item Ausdruck: $\{x_1,x_2 \mid \Psi (x_1,x_2,...)\}$
\item Formeln analog zu TRC
\end{itemize}

\begin{figure}[H]
\centering
\includegraphics[scale=.4]{pictures/bspformeldrc.png}
\caption{Beispielformeln DRC}
\end{figure}

\subsection{Query By Example (QBE)}

\begin{itemize}
\item praktische, visuelle Sprache basierend auf DRC
\item Eingabe über Tabellenskelette mit Variablen (\_x, \_y) \& Befehlen:
\begin{itemize}
\item P. $\rightarrow$ print/select
\item I. $\rightarrow$ insert
\item D. $\rightarrow$ delete
\item U. $\rightarrow$ update
\end{itemize}
\item Join über gleiche Variablen
\item kein NOT verfügbar
\end{itemize}

\begin{figure}[H]
% Obere Reihe
\begin{minipage}[t]{.45\textwidth}
\centering
\includegraphics[scale=.3]{pictures/qbedia1.png}
\end{minipage}
\hfill
\begin{minipage}[t]{.45\textwidth}
\centering
\includegraphics[scale=.3]{pictures/qbedia2.png}
\end{minipage}
\\[1em] % Abstand zwischen den Reihen
% Untere Reihe
\begin{minipage}[t]{.45\textwidth}
\centering
\includegraphics[scale=.3]{pictures/qbedia3.png}
\end{minipage}
\hfill
\begin{minipage}[t]{.45\textwidth}
\centering
\includegraphics[scale=.3]{pictures/qbedia4.png}
\end{minipage}
\caption{Beispieldialog in QBE}
\end{figure}

\begin{figure}[H]
\begin{minipage}[t]{.45\textwidth}
\centering
\includegraphics[scale=.3]{pictures/qbe1.png}
\caption{Abfragen mit Bedingungen}
\end{minipage}
\hfill
\begin{minipage}[t]{.45\textwidth}
\centering
\includegraphics[scale=.3]{pictures/qbe2.png}
\caption{Join-Abfragen in QBE}
\end{minipage}
\\[1em]
\begin{minipage}[t]{.45\textwidth}
\centering
\includegraphics[scale=.3]{pictures/qbe3.png}
\caption{QBE-Abfragen mit Ungleichungen}
\end{minipage}
\hfill
\begin{minipage}[t]{.45\textwidth}
\centering
\includegraphics[scale=.3]{pictures/qbe4.png}
\caption{Abfrage mit Negation}
\end{minipage}
\\[1em]
\begin{minipage}[t]{.45\textwidth}
\centering
\includegraphics[scale=.3]{pictures/qbe5.png}
\caption{Einfügungen}
\end{minipage}
\hfill
\begin{minipage}[t]{.45\textwidth}
\centering
\includegraphics[scale=.3]{pictures/qbe6.png}
\caption{Löschungen \& Aktualisierungen}
\end{minipage}
\\[1em]
\centering
\includegraphics[scale=.3]{pictures/qbe7.png}
\caption{Realisierung QBE-Abfrage ohne Negation}
\end{figure}

\newpage

\section{SQL}

\textbf{basiert auf Mengen- \& relationalen Operatoren mit Modifikationen \& Erweiterungen}

\subsection{Grundsruktur einer SQL-Abfrage}

\begin{lstlisting}[language = SQL]
SELECT A1, A2, ... -- Projektion
  FROM R1, R2, ... -- Kreuzprodukt
 WHERE Bedingung -- Selektion
\end{lstlisting}

\subsection{Basisbestandteile}

\textbf{\textcolor{blue}{SELECT}}
\begin{itemize}
\item listet Attribute bzw. Ausdrücke
\item \texttt{*} gibt alle Attribute aus
\item \texttt{\textcolor{blue}{DISTINCT}} entfernt Duplikate
\item Ausdrücke möglich (\texttt{\textcolor{blue}{CAST}...\textcolor{blue}{AS}}, \texttt{\textcolor{blue}{REPLACE}})
\item Alias mit \texttt{\textcolor{blue}{AS}}
\end{itemize}

\noindent
\textbf{\textcolor{blue}{FROM}}
\begin{itemize}
\item enthält Relationen
\item mehrere Relationen $\rightarrow$ kartesisches Produkt
\item gleiche Attributnamen: Quali nötig (z.B. \texttt{R.A} \& \texttt{S:A})
\item Selbst-Joins möglich
\end{itemize}

\noindent
\textbf{\textcolor{blue}{WHERE}}
\begin{itemize}
\item filtert Tupel durch Prädikate
\item Vergleichsoperatoren: =, <, >, <=, >=, <>
\item NULL-checks: \texttt{IS NULL}, \texttt{IS NOT NULL}
\item Logik: AND, OR, NOT
\end{itemize}

\begin{figure}[H]
\begin{minipage}[t]{.45\textwidth}
\centering
\includegraphics[scale=.5]{pictures/db1.png}
\end{minipage}
\hfill
\begin{minipage}[t]{.45\textwidth}
\centering
\includegraphics[scale=.35]{pictures/db2.png}
\end{minipage}
\caption{Datenbank- \& Relationenschema}
\end{figure}

\noindent
\textbf{Beispielabfrage mit SQL}
\begin{lstlisting}[language = SQL]
SELECT Kontaktname, CAST(REPLACE("Telefon",'-','') AS INT) AS "NUMMER"
  FROM LIEFERANTEN;
\end{lstlisting}

$\Rightarrow$ Ausgegeben werden die Kontaktnamen \& Telefonnummern.

\subsection{NULL-Werte}

\begin{itemize}
\item NULL = unbekannt/nicht vorhanden
\item Rechenoperatoren mit NULL $\rightarrow$ NULL
\item Logik folgt TRUE/FALSE/NULL
\item Aggregatfunktionen ignorieren \texttt{\textcolor{blue}{NULL}} außer \texttt{\textcolor{blue}{COUNT}(*)}
\end{itemize}

\subsection{Joins}

\begin{itemize}
\item über Bedingungen formuliert oder explizite JOIN-Operatoren
\item Arten:
\begin{itemize}
\item INNER JOIN
\item LEFT/RIGHT OUTER JOIN
\item FULL OUTER JOIN
\item NATURAL JOIN/JOIN USING
\end{itemize}
\item Special: FULL OUTER JOIN kann simuliert werden mit:
\begin{lstlisting}[language = SQL]
SELECT ... FROM A LEFT JOIN B ...
UNION
SELECT ... FROM A RIGHT JOIN B ...
\end{lstlisting}
\end{itemize}

\noindent
Typische Anwendungen:
\begin{itemize}
\item Kunden + Bestellungen
\item Produkte + Angebote
\item Selbst-Joins (z.B. Kunden in gleicher Stadt)
\end{itemize}

\subsection{Mengenoperationen}

\begin{itemize}
\item \texttt{\textcolor{blue}{UNION}} ($\cap$, ohne Duplikate)
\item \texttt{\textcolor{blue}{UNION ALL}} (mit Duplikaten)
\item \texttt{\textcolor{blue}{INTERSECT}} ($\cup$)
\item \texttt{\textcolor{blue}{EXCEPT}} ($-$, wie das logische Ohne)
\item Anforderungen:
\begin{enumerate}
\item gleiche Anzahl an Spalten
\item kompatible Datentypen
\end{enumerate}
\end{itemize}

\subsection{ORDER BY \& Sortierung}

\begin{itemize}
\item \texttt{\textcolor{blue}{ASC}} Standard \& \texttt{\textcolor{blue}{DESC}}
\item mehrere Sortierschlüssel möglich
\item Umgang mit \texttt{\textcolor{blue}{NULL}}:
\begin{itemize}
\item MySQL: \texttt{\textcolor{blue}{NULLS FIRST}}
\item PostgreSQL/DuckDB: \texttt{\textcolor{blue}{NULLS LAST}}
\end{itemize}
\end{itemize}

\subsection{Aggregation \& GROUP BY}

\textbf{Aggregatfunktionen:} \\
\texttt{\textcolor{blue}{SUM}}, \texttt{\textcolor{blue}{COUNT}}, \texttt{\textcolor{blue}{AVG}}, \texttt{\textcolor{blue}{MIN}}, \texttt{\textcolor{blue}{MAX}}

\begin{figure}[H]
\centering
\includegraphics[scale=.5]{pictures/sqlaus.png}
\caption{SQL-Ausführungsreihenfolge}
\end{figure}

\noindent
\textbf{ACHTUNG:} Attribute in \texttt{\textcolor{blue}{SELECT}} ohne Aggregat müssen in \texttt{\textcolor{blue}{GROUP BY}} stehen \& \texttt{\textcolor{blue}{HAVING}} filtert Gruppen, nicht einzelne Tupel. \\
Mit \texttt{\textcolor{blue}{LIMIT}} kann die Ausgabe auf eine bestimmte Anzahl n reduziert werden (z.B. Top 3 Käufer mit den meisten Bestellungen).

\subsection{Subqueries (Unterabfragen)}

\textbf{Arten:}
\begin{itemize}
\item korreliert (bezieht sich auf äußere Abfrage)
\item unkorreliert
\end{itemize}

\noindent
\textbf{Nutzen}
\begin{itemize}
\item Vergleiche mit Standardwerten (z.B. durchschnittlicher Bestellwert)
\item Mengenvergleiche:
\begin{itemize}
\item \texttt{\textcolor{blue}{IN}}: Ausgabe der Datensätze aus Hauptanfrage im Ergebnis der Unterabfrage
\item \texttt{\textcolor{blue}{NOT IN}}: nicht im Ergebnis der Unterabfrage
\item \texttt{\textcolor{blue}{ANY}}: wenn min. eins zu \texttt{\textcolor{blue}{TRUE}} evaluiert
\item \texttt{\textcolor{blue}{ALL}}: \texttt{\textcolor{blue}{TRUE}} wenn alle Werte Bedingung erfüllen
\item \texttt{\textcolor{blue}{EXISTS}}: \texttt{\textcolor{blue}{TRUE}} wenn Unterabfrage min 1 Datensatz liefert
\item \texttt{\textcolor{blue}{NOT EXISTS}}: \texttt{\textcolor{blue}{TRUE}} wenn keine Datensätze liefert
\end{itemize}
\end{itemize}

\newpage

Beispiele:
\begin{itemize}
\item Kunden ohne Bestellung (NOT EXISTS)
\item Produkte günstiger als jedes Getränl (ALL)
\item Kunden mit hoher Bestellung (> 500) (IN)
\end{itemize}

\subsection{Änderung an der Datenbank}

\begin{lstlisting}[language = SQL]
DELETE FROM Kunden WHERE ...
\end{lstlisting}
\noindent
\textbf{Wichtig:} Unterabfragen werden einmal evaluiert, bevor die Löschaktion ausgeführt wird. \\
\\
\noindent
\textbf{\texttt{\textcolor{blue}{INSERT}}}
\begin{itemize}
\item mit oder ohne explizite Attributliste
\item mehrere Werte möglich
\end{itemize}
\noindent
\textbf{\texttt{\textcolor{blue}{UPDATE}}}
\begin{itemize}
\item einzelnes Attribut oder mehrere ändern
\item Wert kann auch aus Subquery stammen
\end{itemize}

\end{document}